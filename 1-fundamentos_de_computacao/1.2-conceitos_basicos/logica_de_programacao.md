# PENSAMENTO COMPUTACIONAL
 O pensamento computacional √© uma estrat√©gia que permite resolver problemas de forma eficiente, criando solu√ß√µes gen√©ricas para problemas variados pertencentes a uma mesma classe. Ele refere-se ao processo de pensamento envolvido na express√£o de solu√ß√µes em passos computacionais (algoritmos) que podem ser implementados no computador. De forma geral, √© a formula√ß√£o de passos l√≥gicos para a solu√ß√£o e resolu√ß√£o de problemas computacionais (sistem√°tico e eficiente).<br/>
 √â baseado em 4 pilares:
<pre>
1. Decomposi√ß√£o >  Dividis√£o¬π ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
2. Padr√µes      >            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
3. Abstra√ß√£o    >       ¬≤Repeti√ß√£o‚îÄ‚îÄ+‚îÄ‚îÄ¬≥Foco
4. Algoritmos   >            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    v
                              GENERALIZA√á√ÉO
                                   ||
                              ESTRUTURA√á√ÉO -> Execu√ß√£o‚Å¥
</pre>
## 1. DECOMPOSI√á√ÉO:<br/>Dividir um problema complexo em subproblemas.
 A√ß√£o de dividir um problema em partes menores; a ideia √© resolver as partes do problema para ent√£o obter a resposta do todo. Na computa√ß√£o, quando escrevemos algum software ou c√≥digo, geralmente dividimos a escrita em partes menores que v√£o sendo constru√≠das aos poucos.<br/>
 √â preciso compreender como executar cada etapa de um pensamento computacional. *"Quebrar"* o problema √© o 1¬∫ passo da resolu√ß√£o de problemas: dividir um problema complexo em problemas menores = problemas mais f√°ceis de se resolver.<br/>
**Estrat√©gia:**
<pre>
                                        _          _/         __   ___
Processo de quebrar e determinar \\    /_\  |\ |  /_\  |   | |__  |__
partes menores e gerenci√°veis    //   /   \ | \| /   \ |__ |  __| |___
                                       ___  /     _____  ____  ___   ____
(RE)Combinar os elementos        \\   |___  | |\ |  |   |___  |___  |___
recompondo o problema original   //    ___| | | \|  |   |____  ___| |____

Ordem de execu√ß√£o de \\ > Sequencial -> Depend√™ncia entre tarefas executadas em fila
tarefas menores      // > Paralelo   -> Tarefas podem ser executadas concomitentemente (+ eficiencia - tempo).
</pre>
### *Como Decompor?*
**Identificar/coletar os dados    =>    Agregar os dados    =>    Funcionalidade    =>    Decomposi√ß√£o**
<pre>
Exemplos de Decomposi√ß√£o:

COZINHAR
- Identificar os ingredientes
- Determinar as etapas (sequencial ou paralelo)
- Executar cada etapa
- Agregar/agrupar os ingredientes para finalizar (recompor com coer√™ncia)

FUNCIONAMENTO DE UM OBJETO/SISTEMA
- Identificar os componentes
- Papel de cada componente
- Interdepend√™ncia entre os componentes/pe√ßas

CRIAR UM APP
- Finalidade       \ 
- Interface         \  Defini√ß√£o de componentes e etapas
- Funcionalidades   /
- Pr√©-requisitos   /

DOCUMENTA√á√ÉO
- O que ser√° abordado     \ 
- Estrutura                \  Defini√ß√£o de componentes e etapas
- Conte√∫do de cada t√≥pico  /
- Textos de conex√£o       /

MOVIMENTOS DE UM AVATAR
                  ___________________A√á√ïES____________________
                 ‚Üì                                            ‚Üì
           ____PADR√ÉO_____                         ________MOVIMENTO______
          ‚Üô               ‚Üò                       ‚Üô       ‚Üì      ‚Üì        ‚Üò
    __VIRAR__          __MOVER__               ANDAR   CORRER  SENTAR  LEVANTAR
   ‚Üô         ‚Üò        ‚Üô         ‚Üò                     ‚Üô      ‚Üò 
DIREITA  ESQUERDA   CIMA       BAIXO           MOVER PERNA  IMPULSIONAR
</pre>
## 2. PADR√ïES
 Observa√ß√£o e identifica√ß√£o de similaridades, recorr√™ncias e tend√™ncias em dados ou a√ß√µes. A√ß√£o de descrever o que vai acontecer com base em evento anteriores. Na computa√ß√£o, √© comum utilizar estruturas de repeti√ß√£o, por exemplo, para blocos de c√≥digos semelhantes que se repetem de alguma forma ou agrupar e reutilizar dados que s√£o usados repetidamente.

### RECONHECIMENTO DE PADR√ïES
- *Modelo base*
- *Estrutura variante*
- *Repeti√ß√£o*

 **Roteiro: um modelo de refer√™ncia que determina uma estrutura invariante e que pode determinar repeti√ß√£o. A partir de um modelo podemos determinar objetos diferentes em que uma estrutura se repete.*

> Exemplo: Cadeiras -> ü¶Ωü¶ºüí∫ü™ëüõãÔ∏è
><pre>
>Padr√£o     \ - P√©
>Refer√™ncia / - Assento
></pre>
### *Como Reconhecer Padr√µes Dentro do Contexto?*
 *Atrav√©s das similaridades e diferen√ßas.*

>Exemplo: Fotos de redes sociais (t√©cnica de compress√£o e armazenamento):
> - Foto > Compress√£o > Salvo no BD = Processo de Armazenamento Padr√£o Utilizado por Diferentes Redes Sociais
<pre>
Compress√£o de Dados:
 _____   _____   _____   _____   _____   _____   _____   _____   _____   _____   \ 
|     | |     | |_____| |_____| |+++++| |+++++| |     | |     | |     | |     |   \ Compress√£o por
|*****| |*****| |_____| |_____| |+++++| |+++++| |/////| |*****| |     | |/////|   / Reconhecimento de Padr√µes
|_____| |_____| |_____| |_____| |¬±¬±¬±¬±¬±| |¬±¬±¬±¬±¬±| |_____| |_____| |_____| |_____|  /

[ ] = 1
[+] = 2
[-] = 2
[/] = 2
[*] = 3
</pre>
### *Por Que Determinar Padr√µes?*
 *Generalizar com objetivo de obter resolu√ß√£o para problemas diferentes.*
<pre>
 _______________________________________________________________
|                                                               |
| Classificar -> Categorias -> Grupos de Objetos Semelhantes    |
|                                                               |
|                      Caracteristicas \            Grupo de    |
| Classe = estrutura ‚ùÆ                  ‚ùØ comuns -> Objetos     |
|                      Comportametos   /            Semelhantes |
|_______________________________________________________________|
*Objetos = Inst√¢ncias de uma Classe
</pre>
- **Categoria**<br/>Agrupa elementos com base em caracter√≠sticas/propriedades semelhantes, exemplo: *"mam√≠feros"*, *"aves"*, etc.
- **Classe**<br/>√â uma subdivis√£o mais espec√≠fica de uma categoria. No exemplo anterior, a categoria *"aves"* pode ser subdividida em: *"aqu√°ticas"*, *"terrestres"* e *"voadoras"*.

### *Como Detectar e Determinar Padr√µes?*
*- Grau de Similaridades*<br/>
*- Grupos Conhecidos e Grupos Desconhecidos*

### *Como o Computador Reconhece Padr√µes?*
**Por compara√ß√£o**: Se ele n√£o possui a informa√ß√£o n√£o ser√° capaz de realizar a compara√ß√£o.
<pre>
                                ‚¨êsubjetividade‚¨é
Como Simular o Comportamento de Machine Learning?

Representa√ß√£o de Atributos
             ‚§∑  Aprendizado ‚ûù Conceito Associado  
                                   ao Objeto
                            Armazenar  ‚§∂
                            os Dados
                               '-‚á¢ Para consutas posteriores, poder determinar p/
                                     um novo objeto qual categoria ele se encaixa
                                                        |
                                    Regras de          ‚§é
                                     Decis√£o
                                     Exemplo
                                        ‚Üì
 Possui todas as carater√≠sticas   ‚ùÆ Objeto "1"
 de uma determinada categoria "A"
                  ‚Üò
                   Ent√£o, objeto "A" √© da categoria "1"

Extra√ß√£o de Caracter√≠sticas  \ 
            ‚Üì                 \ 
           para                ‚ùØ Abordagem
            ‚Üì                 /
   Classifica√ß√£o de Dados    /

Diferentes M√©todos e Aplica√ß√µes
</pre>
## 3. ABSTRA√á√ÉO
Identifica√ß√£o dos princ√≠pios gerais que criam padr√µes, mantendo o foco nos aspectos essenciais e ignorando os detalhes menos importantes, de modo que a solu√ß√£o possa ser v√°lida para outros problemas da mesma natureza. *"Abstrair o que √© mais importante e ordenar as relevancias, extrapolando o conceito do problema para uma forma generalista."*
- A√ß√£o de ignorar os detalhes de uma solu√ß√£o de modo que ela possa ser v√°lida para diversos problemas (generalista).
- Isolar aspectos relevantes do problema para trat√°-los de forma individual (linkando -> decomposi√ß√£o).
- Na computa√ß√£o, quando pensamos em criar um software, pensamos primeiro no que ele deve ser, deixando os detalhes para depois.
  - **ABSTRAIR**: Observar, um ou mais elementos, avaliando caracter√≠sticas e propriedades separadas.
  - **ABSTRA√á√ÉO**: √â um processo intelectual de isolamento de um objeto da realidade.
  - **GENERALIZAR**: A partir de um objeto, criar novos objetos relacionados. Tornar geral, mais amplo, mais extenso.
<pre>
Pegar os elementos principais           =>          Extrapol√°-lo para o          =>            Tornar
de um determinado objeto                            mundo das ideias                           geral
</pre>
### GENERALIZA√á√ÉO x ABSTRA√á√ÉO
 Na l√≥gica, √© a opera√ß√£o intelectual que consiste em reunir numa classe geral, um conjunto de seres ou fen√¥menos similares.

### *Como Classificar os Dados?*
*- Caracter√≠sticas*<br/>
*- Pontos Essenciais*<br/>
*- Generalizar x Detalhar*
<pre>
Representa√ß√£o dos Dados:

-- Estudantes ------------------------> Caracter√≠sticas: -----------------------
|  (geral - usado para todos os alunos)                                        |
|                                       >PONTOS ESSENCIAIS:  >DETALHES         |
|                                       -Matr√≠cula           -Trabalho         |
|                                       -Nome                -Filhos           |
|                                       -Idade               -Cursos Extras    |
|                                       -Sexo                -Data de Ingresso |
|                                       -Endere√ßo                              |
|                                       -Campus                                |
|                                       -Curso                                 |
|                                       -Contato                               |
--------------------------------------------------------------------------------
</pre>
## 4. ALGORITMO
 Segundo o dicion√°rio, algoritmos s√£o uma s√©rie fixa de tarefas, a√ß√µes ou racioc√≠nios que, realizados passo-a-passo, levam a determinado resultado pretendido. Tecnicamente falando, √© uma sequ√™ncia finita e n√£o amb√≠gua de instru√ß√µes comput√°veis que, aplicadas a um conjunto de dados, conduzem √† solu√ß√£o de um problema e/ou permitem realizar certa tarefa. De forma pr√°tica, √© a a√ß√£o de pensar na solu√ß√£o de um problema a partir de uma sequ√™ncia finita de passos. Ent√£o podemos dizer que, um algoritmo √© um conjunto de regras e procedimento l√≥gicos perfeitamente definidos, que levam a solu√ß√£o de um problema em um n√∫mero finito de etapas. Na computa√ß√£o, quando escrevemos um c√≥digo, descrevemos o passo-a-passo l√≥gico que o computador deve fazer para realizar uma tarefa ou atividade. Um programa √© basicamente uma sequ√™ncia de instru√ß√µes/comandos que s√£o dadas ao computador para efetuar alguma tarefa, ou seja resolver um problema. Programa = Algoritmo = Sistema.<br/>
 **Automatizar: Definir passo-a-passo da execu√ß√£o da tarefa.*
<pre>
Ciclo de Processamento:

         ALGORITMO
             ‚§∫
Input  ‚ûù  Process  ‚ûù  Output
             ‚§ª
</pre>
 **O processamento √© a execu√ß√£o dos passos l√≥gicos necess√°rios para que os elementos de entrada se transformem em dados/informa√ß√µes na sa√≠da.*

 **Ex.: Receita de Bolo**: ingredientes (entrada) -> misturar e assar os ingredientes (processamento) -> sa√≠da (bolo).<br/>
Observe que o modo de preparo *- processamento (instru√ß√µes para realizar a tarefa = algoritmo) -* deve ser apresentado de forma l√≥gica, imperativa/infinitiva e n√£o deve apresentar ambiguidades.
<pre>
M√©todo L√≥gico:

                 /               Indu√ß√£o
                / Indu√ß√£o -> Fen√¥meno Observado -> Leis e Teorias
Classifica√ß√£o  /                 Dedu√ß√£o
               \ Fen√¥meno Observado -> Leis e Teorias -> Previs√µes e Explica√ß√µes
                \                Abdu√ß√£o
                 \  Conclus√£o -> Abdu√ß√£o -> Premissa
Tipos:
                                 Infer√™ncia
                                ‚Üô          ‚Üò 
                           Sint√©tica      Anal√≠tica
                           ‚Üô       ‚Üò          ‚Üì
                       Abdu√ß√£o   Indu√ß√£o   Dedu√ß√£o

Design de Algoritmos:

                                   An√°lise
                             (definir a solu√ß√£o)
                            /                   \
                      Refinamento              Teste
            (Aperfei√ßoamento da solu√ß√£o) „Éº (testar a solu√ß√£o)

Processo Cont√≠nuo:

                              Racioc√≠nio LoÃÅgico
                             /                 \ 
                       Refinamento         Decomposi√ß√£o
                            |                   |
                        Algoritmos           Padr√µes
                              \   Abstra√ß√£o  /
</pre>
**Aplica√ß√µes:**
1. *CS + Math*: Desenvolvimento e Abstra√ß√£o, Reconhecimento de Padr√µes
2. *CS + Sci/Eng*: An√°lise de Dados e Design de Solu√ß√µes, Deficina√ß√£o e Uso de Abstra√ß√µes, Testes e Refinamentos de Algoritmos
3. *Math + Sci/Eng*: Desenvolvimento e Abstra√ß√£o, Reconhecimento de Padr√µes
4. *CS + Math + Sci/Eng*: Modelagem, Defini√ß√£o de Problemas, Defini√ß√£o e Uso de Abstra√ß√µes, Reconhecimento de Padr√µes

### Racioc√≠nio LoÃÅgico
 Para escrevermos algoritmos usamos a l√≥gica, que √© a maneira de organizar nosso racioc√≠nio de forma rigorosa e coerente, em forma de pensamento estruturado (organizado em passos l√≥gicos), para permitir encontrar a conclus√£o que determina a resolu√ß√£o de um problema.<br/>
 Exemplo de Racioc√≠nio LoÃÅgico:<br/>
 Um pai, uma m√£e e seu casal de filhos est√£o sentados em uma mesa. Os homens s√£o Roberto e S√©rgio, as mulheres Tereza e Fernanda. Sabe-se que o pai est√° √† frente de Fernanda e o filho √† sua esquerda, enquanto a m√£e est√° ao lado de S√©rgio.
<pre>
                 Fernanda
                 (FILHA)
            ___________________
  Filho    |                   |    (M√ÉE)
(ROBERTO)  |                   |   (TEREZA)
           |___________________|   
                    Pai
                  (S√âRGIO)
</pre>

**Processo de resolu√ß√£o de problemas "step-by-step" utilizando instru√ß√µes:**
><pre>
>O que precisa ser feito?    ‚§µ
>                          Instru√ß√µes
>Qual a ordem de execu√ß√£o?   ‚§¥
></pre>
>Dados -> Manipula√ß√£o / Processamento dos Dados -> Armazenamento dos Dados

**Aperfei√ßoamento = Melhoria = Aprimoramento = Refinamento**: *A partir de uma solu√ß√£o, determinar pontos de melhoria e refinamento.*
<pre>
Ato de Aperfei√ßoar:

Encontrar Solu√ß√£o Eficiente    \ Melhor Uso de Recursos
Otimizar Processos             /
Simplificar Linhas de C√≥digo   \ Melhores C√≥digos e Algoritmos
Fun√ß√µes Bem Definidas          /

         ‚û¶ Efici√™ncia \                      Programas:
Computador             ‚ùØ        Precisam ser determinadas as instru√ß√µes 
         ‚û• Velocidade / detalhadas p/ a execu√ß√£o da tarefa e processamento dos dados
</pre>

# L√ìGICA DE PROGRAMA√á√ÉO

* *O que √© l√≥gica?*<br/>
 Forma de Pensamento estruturada que visa a determina√ß√£o do que √© verdadeiro ou n√£o; Sequ√™ncia *"√≥bvia"* a se seguir e executar para atingir um objetivo ou solucionar um problema.

* *O que √© problema?*<br/>
 √â uma quest√£o que foge a uma determinada regra, √© um desvio de percurso o qual impede de atingir um objetivo com efici√™ncia e efic√°cia e/ou finalizar uma tarefa.

* *O que √© l√≥gica de programa√ß√£o?*<br/>
 Organiza√ß√£o e planejamento das instru√ß√µes assertivas em um algoritmo a fim de viabilizar a implanta√ß√£o de um programa.

 A l√≥gica √© o conhecimento b√°sico necess√°rio para escrever um algoritmo. Ela √© a maneira como organizamos nosso racioc√≠nio de forma coerente e eficiente. Por meio da l√≥gica, raciocinamos sobre o problema e pensamos na sequ√™ncia de passos necess√°rios para resolv√™-lo.

## T√âCNICAS DE L√ìGICA DE PROGRAMA√á√ÉO<br/>Modelos de Desenvolvimento e solu√ß√£o

### T√©cnica Linear
‚í∂-----o---o---o-----‚í∑

- Modelo tradicional
- N√£o tem v√≠nculo
- Estrutura hierarquica
- Programa√ß√£o de computadores
- Execu√ß√£o sequenciada
- √önica dimens√£o
- Ordena√ß√£o de elementos por uma √∫nica propriedade

### T√©cnica Estruturada
‚†Ä‚†Ä  ‚îå----o----‚îê<br/>
‚í∂---o----o----‚í∑

 Organiza√ß√£o, disposi√ß√£o e ordem dos elementos essenciais que comp√µem um corpo (concreto ou abstrato).
<pre>
           /    ‚û¶ Programas
          /  Escrita
Objetivo ‚ùÆ   Entendimento
          \  Valida√ß√£o
           \ Manuten√ß√£o
                ‚û• Facilitada
</pre>

### T√©cnica Modular
<pre>
 ________________________ 
| [M√ìDULO 1]             |      ->      Partes independentes
|              [M√ìDULO 3]|                       ‚Üì
|   [M√ìDULO 2]           |      Controladas por um conjunto de regras
|            [M√ìDULO 4]  |
|________________________|    *Cada m√≥dulo possui suas pr√≥prias regras

*Modelo padr√£o da t√©cnica modular:*
Entrada de dados   ->   Processo de transforma√ß√£o   ->   Dados de sa√≠da

       / - Simplifica√ß√£o
Metas ‚ùÆ  - Decomposi√ß√£o do problema
       \ - Verifica√ß√£o do m√≥dulo
</pre>
## FUNDAMENTOS DE ALGORITMOS

**Primeiros passos para come√ßar a programar:**
1. *Tipologia de dados e vari√°veis*
2. *Instru√ß√µes primitivas*
3. *Estruturas condicionais e operadores*
4. *Estruturas de repeti√ß√£o*
5. *Vetores e matrizes*
6. *Fun√ß√µes*
7. *Instru√ß√µes de entrada e sa√≠da*

### TIPOLOGIA DE DADOS E VARI√ÅVEIS
<pre>
          ‚¨ê  INFORMA√á√ÉO     ‚Ü∞
  input de                   que geram
   DADOS                       DADOS
inicializam              processam e tratam
      ‚Ü≥       INSTRU√á√ïES
        realiza opera√ß√µes que ‚¨è
</pre>
#### TIPOS DE DADOS
 Dados s√£o qualquer objeto que possa ser manipulado pelo computador, um dado pode ser um n√∫mero, uma letra ou uma palavra que se transforma em informa√ß√£o utiliz√°vel quando contextualizadas. Diferentes tipos de dados de dados s√£o representados de diferentes maneiras pelo computador, por xemplo, um n√∫mero inteiro n√£o √© armazenado internamente da mesma forma que um caracter (embora algumas linguagens de alto n√≠vel permitam at√© certo ponto ignorar a representa√ß√£o interna dos dados). Para algumas linguagens tipadas, √© necess√°rio declarar qual o tipo de dado e qual o comportamento que o dado dever√° ter (em alguns casos como em sistemas embarcados, deve-se especificar tamb√©m o tamanho do dado a ser aceito pela vari√°vel). Ent√£o, em tipos de dados devemos especificar o formato do dado que ser√° armazenado em uma vari√°vel, ou seja, numa posi√ß√£o de mem√≥ria. Assim, ao declararmos uma vari√°vel, al√©m do identificador, precisamos informar o tipo de dado que aquele endere√ßo (vari√°vel) pode armazenar. O tipo de dado implica tamb√©m no espa√ßo de mem√≥ria a ser reservado e ajuda a verificar se o que est√° sendo armazenado naquela posi√ß√£o √© coerente com o que o programador pretendia, pois, em n√≠vel de m√°quina, todos os dados s√£o representados usando uma sequ√™ncia finita de *bits*. J√° se deduz deste fato que nem todos os dados s√£o represent√°veis em um computador. A defini√ß√£o de um tipo de dado inclui a defini√ß√£o do conjunto de valores permitidos e as opera√ß√µes que podem ser realizadas sobre esses valores. Quando um dado √© usado em um programa, seu tipo deve ser determinado para que o tradutor saiba como manuse√°-lo e armazen√°-lo. Dependendo da linguagem, pode ou n√£o ser necess√°rio declarar expressamente o tipo de cada dado no programa. Ou seja, se o programador pretendia armazenar um n√∫mero mas o usu√°rio digita uma letra, isso √© uma incoer√™ncia e pode causar erros. Os espa√ßos na mem√≥ria s√£o diferentes para cada valor, e por isso foram criados os *"Tipos de Dados"*, para criar um padr√£o de tamanho de vari√°veis, a *tipagem de dados* refere-se √† forma como declaramos os tipos de vari√°veis. Por exemplo, alguns declaramos como *inteiros*, outros como *strings*, ou *pontos flutuantes*, e assim por diante, e algumas linguagens nem √© necess√°rio declarar o tipo por ser de *tipagem din√¢mica*, isso quer dizer que diferente da *tipagem forte* presente nas linguagens de *tipagem est√°tica* onde precisamos definir qual o tipo da vari√°vel (fazendo com que aquela vari√°vel aceite apenas aquele tipo de dado durante toda a execu√ß√£o do programa, n√£o permitindo assim opera√ß√µes entre objetos de diferentes tipos), linguagens com *tipagem fraca* mudam os tipos de dados aceitos pelas vari√°veis durante a execu√ß√£o do c√≥digo, dando maior flexibilidade, mas tamb√©m maior chance de problemas durante a execu√ß√£o do programa. Vejamos quais s√£o os principais *tipos b√°sicos* (ou *primitivos*) de dados presentes nas linguagens:
<pre>
           / Int: -3, -2, -1, 0, 1, 2, 3...
Num√©ricos ‚ùÆ
           \ Double¬π (+ precis√£o / + gasto de mem√≥ria) / Float¬≤ (- precis√£o / - gasto de mem√≥ria): -5.5, -1.5, -0.555, 1.3, 5 (5.0), 5.9...

Char      ‚ùÆ ? A # b + C ! d $

String    ‚ùÆ palavras e frases

Bool      ‚ùÆ L√≥gico: FALSO (0) | VERDADEIRO (1)
</pre>
##### TIPAGEM DE DADOS

```C++
#include <iostream>
#include <locale.h>
using namespace std;

int main() {
    setlocale(LC_ALL, "");

    // tipos de dados & vari√°veis
    int inteiros = 3;
    float pontoFlutuante = 0.99;
    double decimais = 9.99;
    char letra = 'a';
    const char* letras = "abcde";
    string texto = "Dev C++";
    bool condicao = true;

    // imprimindo
    cout << "Inteiros: " << inteiros << "\n";
    cout << "Decimais: " << decimais << "\n";
    cout << "Ponto Flutuante: " << pontoFlutuante << "\n";
    cout << "Caractere: " << letra << "\n";
    cout << "Caracteres: " << letras << "\n";
    cout << "String: " << texto << "\n";
    cout << "Booleana: " << condicao << "\n";

    return 0;
}
```

##### ESTRUTURA DE DADOS
 S√£o as diferentes estruturas utilizadas para representar a informa√ß√£o em um computador. Neste sentido, uma estrutura de dados √© uma forma de organizar um conjunto de dados elementares, de forma eficiente, com o objetivo de facilitar seu uso e manipula√ß√£o.<br/>
 Vamos pensar em um exemplo de estrutura de dados, se voc√™ possui uma livraria e est√° desenvolvendo uma aplica√ß√£o para ter um controle do estoque, com uma estrutura de dados eficiente voc√™ poder√° ter as informa√ß√µes representadas, n√£o apenas de um livro em particular, mas de todos os livros que voc√™ tem em um sistema. Desta forma, com estruturas de dados voc√™ pode lidar com grandes quantidades de informa√ß√µes de forma otimizada.<br/>
 Se buscarmos o conceito formal de estrutura de dados, veremos que ele n√£o est√° muito distante do que j√° descrevemos: *"uma estrutura de dados √© uma cole√ß√£o de dados que pode ser caracterizada por sua organiza√ß√£o e pelas opera√ß√µes que nela s√£o definidas".*<br/>
 Em conclus√£o, *estruturas de dados s√£o geralmente baseadas na capacidade do computador de recuperar e armazenar dados em qualquer lugar em sua mem√≥ria.*

##### ESTRUTURA DE BANCO DE DADOS
 Antes de entrarmos nos diferentes tipos de estruturas de dados existentes, vejamos a **diferen√ßa** *entre uma estrutura de dados e uma estrutura de banco de dados.* Como dissemos antes, quando nos perguntamos *o que √© uma estrutura de dados na programa√ß√£o*, especificamos que √© **uma forma de organizar um conjunto de dados com o objetivo de facilitar a sua manipula√ß√£o.**</br>
 Por outro lado, a **estrutura de um banco de dados** *tamb√©m √© um conjunto de dados, mas com a diferen√ßa de que eles pertencem ao mesmo contexto, sendo armazenados  sistematicamente para uso posterior.* Para entender melhor o conceito, vejamos um exemplo, pense em uma biblioteca nos anos 90. Naquele tempo, para encontrar um livro, era preciso procur√°-lo em arquivos em uma parede da biblioteca. Ali, dentro de pequenas prateleiras, estavam os arquivos ordenados por ordem alfab√©tica e por assunto. Ent√£o, voc√™ escreveu o c√≥digo e o levou ao bibliotec√°rio que, atrav√©s desses n√∫meros, p√¥de encontrar a prateleira onde estava o livro e entreg√°-lo a voc√™.<br/>
 Foi o que fizeram os bibliotec√°rios, catalogando livros de forma sistem√°tica para saber onde procur√°-los, √© o que conhecemos hoje como estrutura de um banco de dados. Por que as estruturas de banco de dados s√£o √∫teis? Porque, pensando nisso do ponto de vista da programa√ß√£o, atualmente √© poss√≠vel armazenar grandes quantidades de informa√ß√µes de forma segura, bem como acelerar os processos de busca, tornando-os mais eficientes.</br>
 Pensando nisso a partir da programa√ß√£o da estrutura de dados, poder√≠amos estabelecer uma outra diferen√ßa com rela√ß√£o ao armazenamento. O banco de dados √© armazenado na nuvem ou no disco r√≠gido do PC sob a forma de tabelas, onde a estrutura se refere a como essa tabela √© composta e como a informa√ß√£o √© organizada.</br>

###### TIPOS DE ESTRUTURAS DE DADOS
 Os tipos de estruturas de dados podem ser oganizados usando 2 tipos diferentes de estruturas:
 - **ESTRUTURAS EST√ÅTICAS DE DADOS**: S√£o aquelas em que o tamanho da mem√≥ria ocupada √© definido durante a escrita do programa e n√£o pode ser alterado durante a execu√ß√£o.
 - **ESTRUTURAS DIN√ÇMICAS DE DADOS**: Estes n√£o tem as limita√ß√µes de tamanho da mem√≥ria ocupada. Ao utilizar um tipo de dados espec√≠fico, chamado de *ponteiro*, √© poss√≠vel construir estruturas de dados din√¢micas que s√£o suportatadas pela maioria das linguagens.<br/>
 Ao contr√°rio das estruturas est√°ticas (que cont√©m um espa√ßo definido para armazenar um n√∫mero fixo de elementos), uma estrutura de dados din√¢mica se modifica e expande durante a execu√ß√£o do programa. podem ser classificados em dois grupos distintos: **estruturas de dados lineares** e **n√£o-lineares**.
    - **ESTRUTURAS DE DADOS LINEARES**: As estruturas de dados lineares s√£o caracterizadas pelo fato de que seus elementos s√£o colocados lado a lado e relacionados de forma linear. Cada elemento da estrutura pode ser composto por um ou v√°rios sub-elementos ou campos que podem pertecenr √† qualquer tipo de dado. Existem 3 tipos de estruturas lineares:
      1. Pilhas
      2. Filas
      3. Listas
    - **ESTRUTURAS DE DADOS N√ÉO-LINEARES**: As estruturas de dados n√£o-lineares tamb√©m s√£o conhecidas como *multi-linked*. Nessas estruturas, cada elemento pode ser ligado a qualquer outro componente. Isso significa que cada elemento pode ter m√∫ltiplos sucessores ou m√∫ltiplos predecessores. Existem 2 estruturas de dados n√£o-lineares:
      1. √Årvores
      2. Redes

#### MANIPULA√á√ÉO DE DADOS

##### DECLARA√á√ÉO
vari√°vel = nomeDaVariavel / nome_da_variavel / nome-da-variavel

##### Regras
- *Atribui√ß√£o de 1 ou mais caracteres*
- *1¬∫ caractere do nome deve ser uma letra*
- *O `-` e `_` s√£o os √∫nicos carateres especiais permitidos*
- *Proibido o uso de palavras reservadas*

##### TIPAGEM DE COMPORTAMENTO

###### VARI√ÅVEL
 Para utilizar qualquer dado inputado, este precisa ser armazenado na mem√≥ria do computador, e, para que possamos armazenar este dado, √© necess√°rio realizar a **RESERVA DE MEM√ìRIA**. *A reserva de mem√≥ria se d√° atrav√©s da declara√ß√£o de vari√°veis*, podemos fazer a analogia da mem√≥ria do computador com um arm√°rio de gavetas, utilizadas para guardar coisas de maneira organizada, por exemplo, podemos utilizar uma gaveta para armazenar roupas √≠ntimas, outra para blusas, outras para cal√ßas e assim por diante. Para facilitar a localiza√ßao, normalmente fazemos uso de **IDENTIFICADORES**, *ou seja, colocamos "etiquetas" para identificar o conte√∫do de cada gaveta*. Sabemos que os espa√ßos dentro das gavetas s√£o limitados, portanto, √© preciso saber quando a gaveta est√° cheia. De fato, cada programa que est√° armazenado na mem√≥ria do computador ocupa um espa√ßo, a mem√≥ria do computador √© toda endere√ßada, ou seja, cada byte de mem√≥ria possui um endere√ßo de modo que se possa controlar quais posi√ß√µes est√£o livres ou ocupadas, e tamb√©m para saber o que est√° armazenado em cada endere√ßo. Esses endere√ßos obedecem √† refer√™ncias em nota√ß√£o bin√°ria ou hexadecimal, e seria muito complicado para os programadores utilizarem essas refer√™ncias, assim, as linguagens de programa√ß√£o permitem que se atribua um nome (ou seja, identificadores), para as posi√ß√µes de mem√≥ria da m√°quina. Isso ocorre atrav√©s do que chamamos de **DECLARA√á√ÉO DE VARI√ÅVEIS**. *Em programa√ß√£o, uma vari√°vel √© um local da mem√≥ria do computador cujo o conte√∫do pode ser modificado. S√£o como ponteiros (ou "apelidos" que damos) para o caminho at√© a posi√ß√£o de mem√≥ria onde nosso valor est√° guardado.* Em outras palavras, para manipular e utilizar os dados em um programa, eles devem ser alocados em vari√°veis. Por exemplo, se reservarmos mem√≥ria para armazenar o pre√ßo de um produto, num determinado momento o conte√∫dio pode ser R$ 3,15, em outro momento poder√° ser R$ 3,95 e etc. Esse local de mem√≥ria √© de fato o endere√ßo da mem√≥ria RAM, e √© reprentada por um identificador, que √© o nome da vari√°vel criada (ou seja, um *"apelido"* que daremos para um endere√ßo de mem√≥ria de acordo com o conte√∫do que o nosso programa precisa armazenar), cujo o conte√∫do pode-se alterar no decorrer da execu√ß√£o do programa. Por exemplo, se precisamos reservar mem√≥ria para armazenar a idade de 2 pessoas, podemos por exemplo identificar essas posi√ß√µes como `idade1` e `idade2`, em que cada uma ocupa uma posi√ß√£o na mem√≥ria. No exemplo, `idade1` tem o conte√∫do igual a *29* e `idade2` tem o conte√∫do igual a *26*, sendo `idade1` e `idade2` os identificadores (ou seja, o nome das vari√°veis) *29* e *26* os respectivos conte√∫dos no atual momento. Lembrando que uma vari√°vel s√≥ pode assumir 1 valor por vez.

- **Caracter√≠sticas de vari√°veis**
  - *Mut√°veis*
  - *Inconstantes*
  - *Incertas*
  - *Inst√°veis*

 Uma vari√°vel √© uma estrutura de armazenamento de dado. Podendo assumir qualquer um dos valores de um determinado conjunto de valores, contudo, ela est√° restrita ao seu tipo, ou seja, ela s√≥ pode assumir um tipo de valor por vez.
<pre>
           /    A√á√ÉO   -> modifica√ß√£o/altera√ß√£o/manipula√ß√£o de estado
P√°peis da ‚ùÆ      ou
vari√°vel   \  CONTROLE -> monitorada/vigiada
</pre>

###### TIPOS DE VARI√ÅVEIS
 O **escopo** (*scope*) de uma vari√°vel √© o contexto (a √°rea do programa) no qual a vari√°vel √© vis√≠vel/acess√≠vel (declarada), e portanto pode ser usada. O escopo determina a acessibilidade de nosso c√≥digo, ou seja, de onde podemos acessar nossas vari√°veis. Temos dois escopos para as vari√°veis:
 - **Global**: Podemos acess√°-los de qualquer lugar em nosso c√≥digo.
 - **Local**: Podemos acess√°-los apenas dentro do escopo em que foram definidos. Normalmente funciona. Eles ser√£o acess√≠veis de dentro da pr√≥pria fun√ß√£o ou de fun√ß√µes aninhadas em n√≠veis mais altos do que a fun√ß√£o anterior. Ou seja, vari√°veis locais podem ser vistas de dentro para fora, mas nunca de fora para dentro da fun√ß√£o.

 A recomenda√ß√£o geral √© definir como vari√°veis locais todas as vari√°veis que s√£o usadas exclusivamente para executar as tarefas atribu√≠das a cada fun√ß√£o. As vari√°veis globais s√£o usadas para compartilhar vari√°veis entre fun√ß√µes de uma maneira simples.

* **var:**
  - Tipo global, ou seja, √© acessada em *"qualquer lugar"* do c√≥digo.
  - Pode ser reatribu√≠da e redeclarada.
  - N√£o respeita o escopo de bloco (por exemplo, dentro de uma instru√ß√£o `if` ou `for`).

```JS
var x = 10;

if(true) {
    var x = 20; // A vari√°vel 'x' √© a mesma dentro e fora do bloco
    console.log(x) // 20
}

console.log(x); // 20
```

- **let:**
  - Introduz o escopo de bloco, o que significa que a vari√°vel √© vis√≠vel apenas dentro do bloco onde foi declarada (por exemplo, dentro de um `if`, `for` ou {}).
  - Pode ser reatribu√≠da, mas n√£o declarada no mesmo escopo.

```JS
let y = 10;

if(true) {
    let y = 20; // A vari√°vel 'y' possui um valor dentro do bloco
    console.log(y) // 20
}
// e outro valor fora do bloco
console.log(y); // 10
```

###### CONSTANTE
Tudo aquilo que √© fixo e est√°vel.
><pre>
>Exemplo: œÄ = 3.14, Œ¶ = 1.618, dobro (valor * 2 = dobro), metade (valor / 2 = metade)
>                                      var  const  var             var  const  var
><pre>

###### TIPOS DE CONSTANTES

* **const:**
  - Similar ao `let` em rela√ß√£o ao escopo de bloco.
  - No entanto, uma vez atribu√≠da, o valor n√£o pode ser substitu√≠do/reatribu√≠do.

```JS
const Z = 10;

Z = 20;

console.log(Z); // Isso resultaria em erro, pois `const` n√£o permite reatribui√ß√£o
```

* **define**:
  - O `#define` em C++ √© uma diretiva de pr√©-processador que √© usada para definir macros, que s√£o substitui√ß√µes de texto.
  - Processamento Pr√©vio: O `#define` √© uma diretiva de pr√©-processador. Isso significa que ele √© processado pelo compilador antes de qualquer compila√ß√£o real do c√≥digo.
  - Sem Verifica√ß√£o de Sintaxe: Quando voc√™ usa `#define`, o pr√©-processador simplesmente substitui cada ocorr√™ncia do token definido pelo texto correspondente, sem verificar a sintaxe. Portanto, √© importante garantir que a substitui√ß√£o seja feita corretamente para evitar erros de compila√ß√£o dif√≠ceis de depurar.
  - Substitui√ß√£o de Texto: O `#define` √© usado para substituir um token por outro em todo o c√≥digo. N√£o h√° tipo de dados associado √† macro definida por `#define`, √© apenas uma substitui√ß√£o de texto.
  - Substitui√ß√£o Direta de Texto: O `#define` n√£o √© afetado por escopos de bloco ou por escopo de fun√ß√£o. Isso significa que a substitui√ß√£o ocorrer√° em todo o c√≥digo, independentemente do escopo.
  - N√£o √© recomendado para tipos complexos: Enquanto o `#define` √© √∫til para definir constantes simples ou para criar abrevia√ß√µes de c√≥digo, ele n√£o √© recomendado para substitui√ß√£o de tipos complexos, estruturas de controle ou fun√ß√µes. Para isso, normalmente s√£o usados tipos de dados constantes ou fun√ß√µes inline.
  - Escopo Global: As macros definidas por `#define` t√™m um escopo global, o que significa que elas s√£o v√°lidas em todo o c√≥digo ap√≥s a defini√ß√£o, at√© o final do arquivo ou at√© que sejam substitu√≠das por outra diretiva #undef.

```C++
#include <iostream>
#include <locale.h>
using namespace std;

// constantes
#define APRESENTACAO cout << "Primeiro nome: " << NOME;
#define NOME "Raphael";

#define SOBRENOME "K. Dias Santos";
const int anoNascimento = 2000;

int main() {
  setlocale(LC_ALL, "Portuguese");

  const string sexo = "Masculino";

  APRESENTACAO;
  cout << "\nSobrenome: " << SOBRENOME;
  cout << "\nAno de nascimento: " << anoNascimento;
  cout << "\nSexo: " << sexo;
}
```

###### OBJETO
 Em JavaScript, um objeto √© uma cole√ß√£o din√¢mica de propriedades, onde cada propriedade √© uma associa√ß√£o entre um nome (ou chave) e um valor. Esse valor pode ser uma simples string, um n√∫mero, um booleano, ou mesmo outra estrutura complexa como um array ou mesmo um outro objeto, permitindo a cria√ß√£o de estruturas de dados aninhadas e complexas.
```JS
let pessoa = {
    nome: "Raphael",
    profissao: "FullStack",
    experiencia: 5,
    stacks: ["JavaScript", "TypeScript"]
}
```

###### VETORES E MATRIZES
<pre>
         ‚îå‚îÄ‚îÄ‚îê
VARI√ÅVEL |  |
         ‚îî‚îÄ‚îÄ‚îò
         ‚îå‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îê
VETOR    |  |  |  |
         ‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îò
         ‚îå‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îê
MATRIZ   ‚îú‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚î§
         ‚îú‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚î§
         ‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îò
</pre>

###### VETOR
 Container ou Matriz Unidimensional, um vetor √© caracterizado por uma vari√°vel dimensionada com tamanho pr√©-fixado, ou seja, √© uma vari√°vel com tamanho fixo que ir√° receber *n* valores. Diferente da vari√°vel que armazena apenas 1 valor por vez, um vetor pode armazenar *n* valores indexados nas respectivas posi√ß√µes quais foram armazenados. Ou seja, vetor √© um agrupamento cont√≠guo de vari√°veis que armazenam valores do mesmo tipo. Um vetor possui 4 importantes caracter√≠sticas, s√£o elas: nome (identificador), tamanho (define o n√∫mero de dados que podem ser armazenados), tipo (tipo dos dados armazenados) e √≠ndices (indica a posi√ß√£o de cada dado no vetor).

###### MATRIZ
 Uma Matriz √© um vetor bidimensional utilizado para armazenar valores do mesmo tipo, ou seja, √© uma tabela organizada em linhas e colunas no fomarto M x N, onde M representa o n¬∫ de LINHAS (horizontal) e N o n¬∫ de COLUNAS (vertical).
<pre>
          colunas
            n ‚Üì
       ‚Ä¢ ‚Ä¢ ‚Ä¢ | ‚Ä¢ ‚Ä¢ ‚Ä¢    \ 
linhas ‚Ä¢ ‚Ä¢ ‚Ä¢ | ‚Ä¢ ‚Ä¢ ‚Ä¢     \   - cole√ß√£o de vari√°veis/vetores
  m ‚Üí  ‚Ä¢ ‚Ä¢ ‚Ä¢ | ‚Ä¢ ‚Ä¢ ‚Ä¢      \ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>    ‚ùØ - contidas/armazenadas juntas em mem√≥ria
       ‚Ä¢ ‚Ä¢ ‚Ä¢ | ‚Ä¢ ‚Ä¢ ‚Ä¢      /
       ‚Ä¢ ‚Ä¢ ‚Ä¢ | ‚Ä¢ ‚Ä¢ ‚Ä¢     /   - √≠ndices (serve para pesquisar/consultar as informa√ß√µes dentro da matriz)
       ‚Ä¢ ‚Ä¢ ‚Ä¢ | ‚Ä¢ ‚Ä¢ ‚Ä¢    /
             v
</pre>
>Exemplo:<br/>
> Armazenar as notas dos alunos para calcular posteriormente a m√©dia.
><pre>
>Aluno_1       Aluno_2    \  vetores:                           1    2
>nota_A = 10   nota_A = 9  ‚ùØ        nota_aluno1 = [A, B]  \  1 [10 | 05] ‚Üê m
>nota_B = 5    nota_B = 3 /         nota_aluno2 = [A, B]  /  2 [09 | 03] ‚Üê m
>                                                               n‚Üë   n‚Üë
>
>indice:
>          /               m   n                           m   n
>vetores ‚ùÆ  notas_aluno1 [1 | 1] = 10   |   notas_aluno2 [2 | 1] = 9
>          \ notas_aluno1 [1 | 2] =  5   |   notas_aluno2 [2 | 2] = 3
>
>Dados das notas dos alunos:
>
>      ‚åê---------------------------- N ----------------------------¬¨
>     /  ALUNO   1¬∫ TRIMESTRE   2¬∫ TRIMESTRE   3¬∫ TRIMESTRE   M√âDIA
>    /  RAPHAEL       9.5            9.9            9.3        9.5
>M ‚ùÆ   D√âBORAH       9.5            9.5            9.9        9.6
>    \  DIEGO         9.3            9.3             9         9.2
>     \ F√ÅTIMA         9              9              9          9
></pre>

###### DEFININDO VETORES/MATRIZES
```C
int vetor[5];
string alfabeto[] = {"A", "B", "C", "D", "E"};

int matriz[3][3];
string tabela[3][3];
```

###### PILHAS (LAST-IN, FIRST-OUT)
 As pilhas s√£o um tipo abstrato de dados, cujo os elementos v√£o se agrupando uns sobre os outros, a inser√ß√£o de novos elementos √© feita apenas em uma extremidade, que √© chamada de *topo*.
<pre>
‚îå‚îÄ‚îÄ‚îÄ‚îê
| ‚Üì | <- topo
‚îú‚îÄ‚îÄ‚îÄ‚î§
| ‚Üì |
‚îú‚îÄ‚îÄ‚îÄ‚î§
| 1 |
‚îî‚îÄ‚îÄ‚îÄ‚îò
</pre>
 Quando √© necess√°rio obter um elemento que esteja na zona central, √© necess√°rio desempilhar os elementos acima dele. Isto se deve a seu mecanismo LIFO, no qual o √∫ltimo elemento que √© colocado na pilha √© o primeiro que pode ser retirado. Os elementos s√£o trazidos apenas em uma extremidade, que neste caso seria o topo da pilha. Sua implementa√ß√£o pode ser realizada por meio de um vetor (ou *array*). Para isso, s√£o utilizados dosi m√©todos: `push()`, que insere um elemento na posi√ß√£o livre seguinte da pilha, e `pop()` que extrai o √∫ltimo elemento do vetor.

###### FILAS (FIRST-IN, FIRST-OUT)
 S√£o caracterizadas por permitir a inser√ß√£o e remo√ß√£o de elementos livres de maneiras opostas. Neste caso, as **exclus√µes** *s√£o feitas no in√≠cio da linha*, enquanto as
**inser√ß√µes** *s√£o feitas na outra extremidade*, ou seja, no final. Os elementos entram na fila pelo "final" e saem da fila pelo "in√≠cio". Sua implementa√ß√£o tamb√©m pode ser feita atrav√©s de um array, usando o m√©todo `shift()`, que *retira* o elemento mais ao "final" da fila e "empurra" os demais para "a frente".
<pre>
 in ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê out
  ‚Üí | ‚Üí | ‚Üí | 1 |  ‚Üí
    ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
</pre>
 As filas na estrutura de dados t√™m um mecanismo conhecido como FIFO. Assim, a diferen√ßa com as pilhas est√° na forma como os dados entram e saem. A utilidade das filas est√° no armazenamento de dados que precisam ser processados por ordem de chegada.
 
###### LISTAS
 Podem ser definidas como uma sequ√™ncia de elementos composta de elementos que s√£o colocados um ap√≥s o outro, que tem a particularidade de um elemento apontar para o pr√≥ximo elemento, e este para o seguinte, e assim por diante. De tal maneira que percorrer uma lista, √© simplesmente ir passando do primeiro elemento, um a um, at√© o √∫ltimo elemento. Onde cada elemento √© conectado ao pr√≥ximo atrav√©s de um link contendo a posi√ß√£o do pr√≥ximo elemento.<br/>
 A implementa√ß√£o das listas pode ser feita usando objetos que se conectam uns aos outros, e tamb√©m podem ser utilizados arrays.
<pre>
 ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îê
 | 1 ‚îú‚îÄ>| 2 ‚îú‚îÄ>| 3 ‚îú‚îÄ>| 4 |
 ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îò  
</pre>

###### √ÅRVORES
 As √°rvores, na estrutura de dados, s√£o uma estrutura n√£o-linear utilizada para representar dados com uma rela√ß√£o hier√°rquica na qual cada elemento tem um √∫nico ancestral e pode ter v√°rios sucessores. Uma classifica√ß√£o de √°rvores na estrutura de dados pode ser feita:
  - **√ÅRVORE GERAL**: Cada elemento pode ter um n√∫mero ilimitado de sub-√°rvores.
  - **√ÅRVORE BIN√ÅRIA**: Estruturas de dados homog√™nea, din√¢mica e n√£o-linear onde cada elemento pode ser seguido por no m√°ximo 2 n√≥s. Dentro delas podemos encontrar:
```mermaid
graph TD
  tittle(COMPLETA)
  A --> B
  A --> C
  B --> D
  B --> E
  C --> F
  C --> G
```
---
```mermaid
graph TD
  tittle(DISTINTAS: Possui uma estrutura diferentes das outras √°rvores.)
  A --> B;
  B --> C
  B --> D
  C --> E
  E --> H
  E --> I
  D --> F
```
---
```mermaid
graph TD
  A --> B;tittle(SIMILAR: Quando sua estrutura √© id√™ntica √† de outras √°rvores bin√°rias, mas as informa√ß√µes armazenadas nos n√≥s s√£o diferentes umas das outras); ·¥ã -->  ü
  A --> C; ·¥ã --> ·¥ç;
  B --> D;  ü --> …¥;
  B --> E;  ü --> ·¥è;
  C --> F; ·¥ç --> ·¥ò;
  D --> G; ·¥ò --> s;
  D --> H; ·¥ò --> ·¥õ;
  F --> I; …¥ --> «´;
  F --> J; …¥ -->  Ä;
```
---
```mermaid
graph TD
  A --> B;tittle(EQUIVALENTE: Quando sua estrutura e informa√ß√µes de seus n√≥s √© id√™ntica √† de outras √°rvores bin√°rias.); ·¥Ä -->  ô
  A --> C; ·¥Ä --> ·¥Ñ
  B --> D;  ô --> ·¥Ö
  B --> E;  ô --> ·¥á
  C --> F; ·¥Ñ --> “ì
  D --> G; ·¥Ö --> …¢
  D --> H; ·¥Ö -->  ú
  F --> I; “ì --> …™
  F --> J; “ì --> ·¥ä
```
---
```mermaid
graph TD
  A --> B; tittle(EQUILIBRADO: As alturas das 2 sub-√°rvores de cada 1 dos n√≥s √© id√™ntica √† de outras √°rvores bin√°rias.); N√ÉO-EQUILIBRADO; ·¥Ä -->  ô
  A --> C; ; ·¥Ä --> ·¥Ñ
  B --> D; ;  ô --> ·¥Ö
  D --> H; ; ·¥Ö -->  ú
  B --> E; ;  ô --> ·¥á
  D --> I; ; ·¥Ö --> …™
  C --> F; ; ·¥Ñ --> “ì
  F --> J; ; ·¥Ñ --> …¢
  C --> G; ; …¢ --> ·¥ã
  G --> K; ; …¢ -->  ü
  G --> L; ; ·¥ã --> ·¥ç
  K --> M; ; 
```
---
```mermaid
graph TD
  tittle(DEGENERADO: Quando seus n√≥s tem apenas 1 sub-√°rvore.)
  A --> C
  C --> G
  G --> L

```
---

###### REDES
 As redes, em estruturas de dados, s√£o outra estrutura n√£o-linear, assim como as √°rvores. Seu conceito √©: *formalmente, uma rede √© um conjunto de pontos - uma estrutura de dados - e um conjunto de linhas, cada uma das quais une um ponto a outro. Os "pontos" s√£o chamados de **n√≥s** (ou v√©rtices) da rede, e as linhas s√£o chamadas de **bordas** (ou arcos)*.<br/>
 Se nos perguntarmos o que √© uma rede e para que serve, podemos dizer que √© uma estrutura matem√°tica que nos permite modelar os problemas cotidianos por meio de uma representa√ß√£o gr√°fica, formada por n√≥s, que exibe as reala√ß√µes entre os diferentes componentes.<br/>
 Podemos usar como exemplo uma rede social, onde s√£o estabelecidas rela√ß√µes entre pessoas que, por sua vez, geram rela√ß√µes entre elas, interagindo, formando assim uma rede.
![Image](https://github.com/user-attachments/assets/ebad1734-7ec7-48f6-8866-6bd27f6241f9)

## INSTRU√á√ïES
 A instru√ß√£o ir√° executar um tipo de a√ß√£o pr√©-determinada para manipular o dado. Aprofundando, instru√ß√µes s√£o como palavras-chave (vocabul√°rio) de uma determinada linguagem de programa√ß√£o que tem como finalidade comandar os recursos do computador que ir√° executar a√ß√µes/tarefas manipulando e tratando dados. Para invocarmos e executar as propriedades de uma instru√ß√£o, usamos seu nome, o nome de cada instru√ß√£o √© √∫nico, e para manter isso, cada linguagem tem sua **PALAVRA RESERVADA**. *Palavra reservada √© toda palavra que √© feita especialmente para o compilador daquela linguagem e o programador n√£o pode usar ela para outro fim que n√£o o definido pelo compilador (a n√£o ser que seja uma String).*
<pre>
 ____________________________‚Ü±________   operadores:
|         c√°lculos matem√°ticos        |   - bin√°rios
|                                     |   - un√°rios
|         /  vari√°veis  \             |
| inputs ‚ùÆ >>opera√ß√µes>> ‚ùØ informa√ß√£o |   -> Instru√ß√µes refere-se a quantidade de operandos (valores ou 
|         \ constantes  /             |      express√µes) com os quais um operador trabalha em um c√°lculo
|_____________________________________|
</pre>

### OPERA√á√ïES MATEM√ÅTICAS
Os operadores **aritm√©ticos** s√£o aqueles utilizados para realiza√ß√£o de opera√ß√µes aritm√©ticas b√°sicas, s√£o agrupados na classe de **operadores bin√°rios**, onde √© necess√°rio a exist√™ncia de mais de 1 valor para a opera√ß√£o resultando em um outro novo valor que, se n√£o armazenado em uma nova vari√°vel n√£o poder√° ser reutilizado, apenas quandoa a opera√ß√£o ocorrer novamente.<br/>
Operadores de **incremento e decremento** s√£o maneiras facilitadas de execu√ß√£o repetidida de valores, se enquadram na classe de operadores **un√°rios**, onde √© a pr√≥pria vari√°vel que ter√° atribu√≠do o resultado da opera√ß√£o com seu valor inicial e um novo valor. Entretanto, √© importante salientar que n√£o podem ser aplicados diretamente √† um n√∫mero (diferente dos operadores aritm√©ticos que podem ser usados diretamente com n√∫meros e vari√°veis), pois, o valor atualizado √© atribu√≠do √† vari√°vel e n√£o ao valor em si, ou seja, est√° sendo atribu√≠do √† vari√°vel um valor atualizado e n√£o operando no pr√≥prio valor.
<pre>
OPERADORES UN√ÅRIOS                                      OPERADORES BIN√ÅRIOS
- positivo......................(+): +a                 - atribui√ß√£o....................(=): a = b
- negativo......................(-): -a                 - adi√ß√£o........................(+): a + b
- incremento...................(++): ++a | a++ (a + 1)  - subtra√ß√£o.....................(-): a - b
- decremento...................(--): --a | a-- (a - 1)  - divis√£o.......................(/): a / b
                                                        - multiplica√ß√£o.................(*): a * b
                                                        - m√≥dulo........................(%): a % b
                                                        - potencia√ß√£o..................(**): a ** b
                                                        - adi√ß√£o e atribui√ß√£o..........(+=): a += 5 (a = a + 5)
                                                        - subtra√ß√£o e atribui√ß√£o.......(-=): a -= 5 (a = a - 5)
                                                        - multiplica√ß√£o e atribui√ß√£o...(*=): a *= 5 (a = a * 5)
                                                        - potencia√ß√£o e atribui√ß√£o....(**=): a **= 5 (a = a ** 5)
                                                        - divis√£o e atribui√ß√£o.........(/=): a /= 2 (a = a / 2)
                                                        - m√≥dulo e atribui√ß√£o..........(%=): a %= 2 (a = a % 2)
</pre>
Exemplo: œÄ * r¬≤ = area

#### PRECED√äNCIA DE OPERADORES
Algumas opera√ß√µes ser√£o aplicadas antes de outras sempre que houver prioridade metem√°tica, al√©m de serem executadas sempre da esquerda para a direita, e de dentro para fora no caso dos par√™nteses. Por exemplo:<br/>
**10 + 5 * 3 + 9 => 10 + 15 + 9 => 25 + 9 = 31**<br/>
**(10 + 5) / (6 - 3) => 15 / 3 = 5**
<pre>
                                            ORDEM HIERARQUICA
OPERADOR          OPERA√á√ÉO             TIPO        PRIORIDADE MATEM√ÅTICA     TIPO DE RETORNO DE RESULTADO
   +         MANUTEN√á√ÉO DE SINAL      UN√ÅRIO                1                          POSITIVO
   -          INVERS√ÉO DE SINAL       UN√ÅRIO                1                          NEGATIVO
  ( )     MANUTEN√á√ÉO DE PRIORIDADE    BIN√ÅRIO               1           INTEIRO OU REAL / POSITIVO OU NEGATIVO
 ^ / **         POTENCIA√á√ÉO           BIN√ÅRIO               2                       INTEIRO OU REAL
   /              DIVIS√ÉO             BIN√ÅRIO               3                            REAL
   /              DIVIS√ÉO             BIN√ÅRIO               4                          INTEIRO
   %               M√ìDULO             BIN√ÅRIO               3                          INTEIRO
   *           MULTIPLICA√á√ÉO          BIN√ÅRIO               3                       INTEIRO OU REAL
   +               ADI√á√ÉO             BIN√ÅRIO               4                       INTEIRO OU REAL
   -              SUBTRA√á√ÉO           BIN√ÅRIO               4                       INTEIRO OU REAL
</pre>

### OPERA√á√ïES COMPARACIONAIS
Operadores **l√≥gicos** s√£o usados tipicamente com valores booleanos, onde avaliam um `valor1` **e**, **ou**, **n√£o** outro `valor2` possuem alguma rela√ß√£o retornando como resultado um valor l√≥gico (`true` ou `false`).  Os operadores **relacionais** comparam seus operandos e retorna um valor booleano baseado no resultado da compara√ß√£o (se `true` ou `false`).
<pre>
- AND.......................(&&): true && true
- OR........................(||): true || false
- NOT/nega√ß√£o l√≥gica.........(!): !true
- maior......................(>): 1 > 0
- maior ou igual............(>=): 1 >= 1
- menor......................(<): 0 < 1
- menor ou igual............(<=): 0 <= 0
- valor igual...............(==): A == a
- valor e tipo iguais......(===): A === A
- diferente............(!= | <>): a != b | a <> b
</pre>

#### AND
 Verifica se/Precisa que todas as entradas atendem/satisfazem o requisito da condi√ß√£o.<br/>
‚úî - A == true && B == true<br/>
‚úó - A == true && B == false<br/>
‚úó - A == false && B == false<br/>
<pre>
CONDI√á√ÉO 1      CONDI√á√ÉO 2      RESULTADO
  FALSA           FALSA           FALSO
VERDADEIRA        FALSA           FALSO
  FALSA         VERDADEIRA        FALSO
VERDADEIRA      VERDADEIRA      VERDADEIRA

Exemplo:
programa{
  funcao inicio(){
    inteiro A = 5, B = 5
    se((A < 10) e (B < 10)){
      escreva("verdadeiro, s√£o menores que 10")
    }senao{
      escreva("falso, um ou todos os n√∫meros √© maior que 10")
    }
  }
}
</pre>

#### OR
 Apenas uma das condi√ß√µes precisa atender ao requisito.<br/>
‚úî - A == true  || B == true<br/>
‚úî - A == true  || B == false<br/>
‚úó - A == false || B == false<br/>
<pre>
CONDI√á√ÉO 1      CONDI√á√ÉO 2      RESULTADO
  FALSA           FALSA           FALSO
VERDADEIRA        FALSA         VERDADEIRA
  FALSA         VERDADEIRA      VERDADEIRA
VERDADEIRA      VERDADEIRA      VERDADEIRA

Exemplo:
programa{
  funcao inicio(){
    inteiro A = 15, B = 5
    se((A < 10) ou (B < 10)){
      escreva("verdadeiro, condi√ß√£o OU satisfeita")
    }senao{
      escreva("falso, condi√ß√£o OU n√£o satisfeita")
    }
  }
}
</pre>

#### NOT
 Operador de nega√ß√£o, inverte o resultado l√≥gico.
- A == true -> !A == false<br/>
<pre>
CONDI√á√ÉO        RESULTADO
  FALSA         VERDADEIRA
VERDADEIRA        FALSA

Exemplo:
programa{
  funcao inicio(){
    logico a = falso
    escreva(!a)
  }
}
</pre>

## ESTRUTURAS DE CONTROLE
 S√£o parte fundamental de qualquer linguagem. Sem elas, as instru√ß√µes de um programa s√≥ poderiam ser executadas na ordem em que s√£o escritas (ordem sequencial). As estruturas de controle permitem que esta ordem seja modificada. H√° 2 categorias de estruturas de controle:
 1. **CONDICIONAL**
 2. **LOOPS**

### ESTRUTURAS CONDICIONAIS E SEUS OPERADORES
 Permitem que diferentes conjuntos de instru√ß√µes sejam executados, dependo se uma determinada condi√ß√£o √© verdadeira ou n√£o. Em termos de programa√ß√£o, se uma condi√ß√£o √© ou n√£o verificada, se traduz em uma *express√£o l√≥gica*, tomando o valor *VERDADEIRO* (true) ou *FALSO* (false). Nos casos mais simples, a condi√ß√£o √© geralmente uma compara√ß√£o entre 2 dados, tais como: se **a < b** faz uma coisa, do contr√°rio far√° outra coisa.
  - *CONDI√á√ÉO* = ESTADO DE UM OBJETO
  - *CONDICIONAL* = EXPRESSA UMA CONDI√á√ÉO
<pre>
Exemplo de estrutura condicional:
(START)  ‚ûù  /a, b/  ‚ûù  [a == b]
                          ‚Üì
          condi√ß√£o -> ‚ùÆ V || F ‚ùØ  ‚ûù  |F|  ‚ûù  [EXCE√á√ÉO]
                        ‚Üì             ~
                       |V|
                        ~
                        ‚Üì
                      (END)
</pre>
#### TIPOS DE ESTRUTURAS CONDICIONAIS
 Podemos definir estruturas condicionais como: *instru√ß√µes a serem seguidas em caso afirmativo*. Observe que, em ambos os casos (quer a condi√ß√£o seja ou n√£o verificada), os *"caminhos bifurcados"* s√£o posteriormenteunidos em um ponto, ou seja, o fluxo do programa recupera seu car√°ter sequencial e continua a ser executado.
<pre>
 SIMPLES                COMPOSTA                      ENCADEADA
[CONDI√á√ÉO]             [CONDI√á√ÉO] ‚ûù [EXCE√á√ÉO]        [CONDI√á√ÉO] ‚¨é
    ‚Üì                      ‚Üì                          ‚Üì        [CONDI√á√ÉO] ‚¨é
[OPERA√á√ÉO]             [OPERA√á√ÉO]                 [OPERA√á√ÉO]       ‚Üì       [OPERA√á√ÉO]
                                                                [EXCE√á√ÉO]

>>>>> CONDICIONAL SIMPLES
√â o tipo mais simples de estrutura condicional. √â utilizada para implementar a√ß√µes condicionais do tipo:
- Se uma determinada condi√ß√£o for cumprida, executar uma s√©rie de instru√ß√µes e, em seguida, proceder.
- Se a condi√ß√£o n√£o for cumprida, n√£o execute as instru√ß√µes.
[CONDI√á√ÉO]                            (START)                 programa{
    ‚Üì                                    ‚Üì                      funcao inicio(){
[OPERA√á√ÉO]                            /A, B/                      logico condicao = verdadeiro
                                         ‚Üì                        se(condicao == verdadeiro){
                                   [X <- A + B]                     escreva("CONDICIONAL SIMPLES")
                                         ‚Üì                        }
                                 N ‚îå-‚ùÆX  > 10‚ùØ-‚îê S              }
                                   |           |              }
                                   |         ‚ùÆ X )
                                   ‚îî----‚ü∂‚óã‚üµ----‚îò
                                         ‚Üì
                                       (END)

>>>>> CONDICIONAL COMPOSTA
Este tipo de estrutura permite a implementa√ß√£o de condicionantes nos quais existem 2 alternativas. Em outras palavras,
neste tipo de estrutura h√° uma escolha: o programa far√° uma coisa ou outra:
- Se uma determinada condi√ß√£o for verificada, executar uma s√©rie de instru√ß√µes (bloco 1).
- Se a condi√ß√£o n√£o for cumprida, executar outro conjunto de instru√ß√µes (bloco 2).
[CONDI√á√ÉO] ‚ûù [EXCE√á√ÉO]                (START)                 programa{
    ‚Üì                                    ‚Üì                      funcao inicio(){
[OPERA√á√ÉO]                            /A, B/                      inteiro decisao = 0, condicao = 1
                                         ‚Üì                        se(condicao == decisao){
                                   [X <- A + B]                     escreva("CONDI√á√ÉO COMPOSTA: ", decisao)
                                         ‚Üì                          }senao{
                                 N ‚îå--‚ùÆX = 10‚ùØ--‚îê S                   escreva("CONDI√á√ÉO COMPOSTA: ", decisao)
                                   |            |                   }
                              [R = X - 5]  [R = X + 5]           }
                                   |            |             }
                                   ‚îî----‚ü∂‚óã‚üµ-----‚îò
                                         ‚Üì
                                       ‚ùÆ R )
                                         ‚Üì
                                       (END)

>>>>> CONDICIONAL ENCADEADA
Permite a implementa√ß√£o de condi√ß√µes mais complexas, nas quais as condi√ß√µes s√£o encadeadas, verificadas e o fluxo sequencial
do programa continua da seguinte maneira:
- Se a condi√ß√£o 1 for verificada, executar as instru√ß√µes do bloco 1.
- Se a condi√ß√£o 1 n√£o for verificada, verificar a condi√ß√£o 2, se esta for satisfeita executar as instru√ß√µes do bloco 2.
- Caso nenhuma das condi√ß√µes precedentes forem verificadas, executar as intru√ß√µes do bloco 3.
[CONDI√á√ÉO] ‚¨é                          (START)                 programa{
 ‚Üì         [CONDI√á√ÉO] ‚¨é                  ‚Üì                      funcao inicio(){
[OPERA√á√ÉO]  |       [OPERA√á√ÉO]         /A, B/                      inteiro resultado, condicao = 15
            ‚Üì                             ‚Üì                        se(condicao <= 10){
          [EXCE√á√ÉO]                 [X <- A + B]                     resultado = condicao + 5
                                          ‚Üì                          escreva("CONDI√á√ÉO COMPOSTA: ", resultado)
                                  N ‚îå-‚ùÆX <= 10‚ùØ-----‚îê S            }senao{
                              N     |     S         |                  se(condicao >= 20){
                              ‚îå-‚ùÆX >= 20‚ùØ-‚îê    [R = X + 5]               resultado = condicao - 5
                              |           |         |                    escreva("CONDI√á√ÉO COMPOSTA: ", resultado)
                         [R = X * 2]   [R = X - 5]  |                  }senao{
                              |           ‚Üì         |                      resultado = condicao * 2
                              ‚îî----------‚ü∂‚óã‚üµ--------‚îò                      escreva("CONDI√á√ÉO COMPOSTA: ", resultado)
                                          ‚Üì                            }
                                        ‚ùÆ R )                       }
                                          ‚Üì                      }
                                        (END)                 }
</pre>

### ESTRUTURAS DE REPETI√á√ÉO
 Uma estrutura de repeti√ß√£o ir√° executar um determinado trecho de um programa a partir dos par√¢metros determinados dentro dessa estrutura. Elas permitem que um conjunto de instru√ß√µes seja executado repetidamente, seja um n√∫mero pr√©-determinado de vezes, ou at√© que uma determinada condi√ß√£o seja verificada. Existem 2 tipos de loops, dependendo se sabemos ou n√£o o n√∫mero de repeti√ß√µes que nosso loops ir√° fazer:
 1. **DETERMINADOS**: `for` - Nos determinados sabemos o n√∫mero de vezes que a instru√ß√£o ser√° repetida.
 2. **INDETERMINADOS**: `while` & `do-while` - Nos indeterminados, n√£o sabemos ao certo quantas vezes um loop se repetir√°, j√° que ser√° repetido at√© que se cumpra uma condi√ß√£o, que a priori, n√£o sabemos quando ser√° cumprida.
<pre>
     ‚§∫
trecho de um /  - Controle de fluxo
  programa   \  - La√ßo/Malha/Loop de repeti√ß√£o
     ‚§ª

                    / N¬∫ de repeti√ß√µes pr√©-fixadas
CONDI√á√ÉO DE PARADA ‚ùÆ              ou
                    \ At√© a condi√ß√£o ser satisfeita
</pre>

#### TIPOS DE ESTRUTURAS DE REPETI√á√ÉO
<pre>
LOOPS
S√£o estruturas de programa√ß√£o que nos permitem executar instru√ß√µes de forma repetitiva dentro de um bloco de c√≥digos.
Al√©m disso, os loops s√£o executados atrav√©s de condi√ß√µes.
Existem 2 tipos de loops:
1. DETERMINADOS: S√£o aqueles em que se sabe quantas vezes um c√≥digo ser√° executado.
    1.1. for
2. INDETERMINADOS
    2.1. while
    2.2. do-while

1. CONDI√á√ÉO DA REPETI√á√ÉO NO IN√çCIO
Permite implementar a repeti√ß√£o do mesmo conjunto de instru√ß√µes, desde que uma determinada condi√ß√£o seja verificada: o
n¬∫ de vezes qaue o ciclo ser√° repetido n√£o √© definido a priori. No in√≠cio de cada itera√ß√£o, a express√£o l√≥gica √© avaliada,
se o resultado for VERDADEIRO, o conjunto de instru√ß√µes √© executado e iteratiza novamente, ou seja, o passo 1 √© repetido.
Se o resultado for FALSO, a execu√ß√£o do loop √© interrompida e o programa continua a ser executado.
ENQUANTO(CONDI√á√ÉO N√ÉO FOR SATISFEITA){
  FA√áA INSTRU√á√ïES
}

2. CONDI√á√ÉO DA REPETI√á√ÉO NO FINAL
Funcionamento semelhante ao WHILE, contudo, ele executa o bloco de instru√ß√µes ao menos uma vez antes de avaliar a express√£o
l√≥gica, pois essa verifica√ß√£o √© feita ao final do loop, ap√≥s a realiza√ß√£o das intru√ß√µes do bloco. Com isso √© importante saber
implement√°-lo, para que o programa n√£o tenha comportamentos inesperados.
FA√áA{
  REPITA INSTRU√á√ïES
}AT√â(CONDI√á√ÉO SER SATISFEITA)

3. ESTRUTURA DE REPETI√á√ÉO COM N√öMERO DE REPETI√á√ÉO INDEXADA
Este tipo de estrutura permite implementar a repeti√ß√£o de um determinado conjunto de instru√ß√£o por um n¬∫ pr√©-determiado
de vezes. Isto √© feito usando uma VARI√ÅVEL DE CONTROLE DE LA√áO (tamb√©m chamada de √çNDICE), que percorre um conjunto
pr√©-fixado de valores em determinada ordem. Para cada valor de √≠ndice desse conjunto, o mesmo conjunto de instru√ß√µes
√© executado uma vez.
PARA(VALOR INICIAL; CONDI√á√ÉO DE PARADA/FA√áA AT√â; ITERA√á√ÉO/ALTERA√á√ÉO DO VALOR INICIAL AT√â ATENDER A CONDI√á√ÉO DE PARADA){
  FA√áA INSTRU√á√ïES
}
</pre>

**EXEMPLOS:**
<pre>
>>>>> ENQUANTO (WHILE)
 Pense numa pessoa indo cortar a grama, a estrutura de repeti√ß√£o l√≥gica a ser aplicada seria:

TESTE L√ìGICO  / ENQUANTO(GRAMA ALTA)FA√áA{
              \   ‚Ü±   APARAR A GRAMA  ‚¨é
REPETI√á√ÉO     /   REPITA(INDEFINIDO)AT√â 
              \       GRAMA APARADA}

VAMOS VER O PSEUDOC√ìDIGO:
 ‚Ü± vari√°vel   ‚Ü± dado booleano
grama    =    falso
 ‚Ü± strutura while
enquanto(grama == falso)fa√ßa{
  &lt;instru√ß√£o para cortar a grama&gt;
  &lt;atualiza status da altura da grama&gt;
}

VAMOS VER O PROGRAMA:
programa{
  funcao inicio(){
    logico grama = falso
    inteiro altura_da_grama = 10, status_altura_da_grama = 0
    enquanto(grama == falso){
      altura_da_grama = altura_da_grama - 1
      escreva("CORTANDO A GRAMA\n")
      se(altura_da_grama == 1){
        grama = verdadeiro
        escreva("GRAMA CORTADA")
      }
    }
  }
}

>>>>>  REPITA AT√â/ENQUANTO (DO...WHILE)
 Assemelha-se ao ENQUANTO (WHILE), por√©m a ordem do teste l√≥gico e da repeti√ß√£o √©:

  FA√áA{
    INSTRU√á√ïES/REPETI√á√ÉO
  }AT√â(CONDI√á√ÉO L√ìGICA)

 Ou seja, executa a instru√ß√£o ao menos 1x.

Imagine que est√° procurando um artigo em uma revista, a estrutura de repeti√ß√£o l√≥gica seria:

              / REPITA{
REPETI√á√ÉO    ‚ùÆ    ‚Ü± ANALISAR CONTE√öDO ¬¨
              \   ‚îî  VIRAR A P√ÅGINA   ‚Ü≤
TESTE L√ìGICO ‚ùÆ }AT√â(ARTIGO ENCONTRADO)

VAMOS VER O PSEUDOC√ìDIGO:
 ‚Ü± vari√°vel   ‚Ü± dado booleano
grama    =    falso
 ‚Ü± strutura while
enquanto(grama == falso)fa√ßa{
  &lt;instru√ß√£o para cortar a grama&gt;
  &lt;atualiza status da altura da grama&gt;
}

VAMOS VER O PROGRAMA:
programa{
  funcao inicio(){
    logico artigo = falso
    inteiro revista = 10, virar_pagina = 1, artigo_encontrado = 5
    faca{
      revista = revista - virar_pagina
      escreva("VIRAR A P√ÅGINA\nANALISANDO CONTE√öDO: p√°gina ", revista, "\n")
      se(revista == artigo_encontrado){
        artigo = verdadeiro
        escreva("ARTIGO ENCONTRADO p√°gina: ", revista)
      }
    }enquanto(artigo == falso)
  }
}

>>>>>  PARA(IN√çCIO; ENQUANTO AT√â; DE N EM N){FA√áA INSTRU√á√ïES} (FOR(){})

  TESTE L√ìGICO -> FEITO NO IN√çCIO
  N¬∫ DE REPETI√á√ïES -> DEFINIDAS/FIXAS

VAMOS VER O PSEUDOC√ìDIGO:
programa{
  funcao inicio(){
//        ‚Ü± vari√°veis             ‚Ü± n¬∫ inteiro
  inteiro contador, somatorio  =  0
//*index: √© a vari√°vel que armazena o novo valor de "contador" ap√≥s cada itera√ß√£o
//       ‚Ü± index*     ‚¨ê n¬∫ repeti√ß√µes ‚¨é  ‚¨ê contagem ‚¨é
    para(contador = 1;  contador <= 10  ;  contador++  ){
      somatorio += contador
      escreva("somatorio: ", somatorio, "\n")
    }
  }
}

A estrutura do for adiciona o valor atual de "contador" (=1) ao valor atual de "somatorio" (=0),
fazendo isso at√© "contador" atingir o valor de parada definido (=10).

1¬™ itera√ß√£o: (contador = 1) + (somatorio = 0) = (somatorio = 1)
2¬™ itera√ß√£o: (contador = 2) + (somatorio = 1) = (somatorio = 3)
3¬™ itera√ß√£o: (contador = 3) + (somatorio = 3) = (somatorio = 6)
4¬™ itera√ß√£o: (contador = 4) + (somatorio = 6) = (somatorio = 10)
5¬™ itera√ß√£o: (contador = 5) + (somatorio = 10) = (somatorio = 15)
6¬™ itera√ß√£o: ...

>>>>>> EXPLICANDO O FOR

Exemplo:
//  ‚Ü± valor de in√≠cio   ‚Ü± condi√ß√£o de parada   ‚Ü± itera√ß√£o at√© atender a condi√ß√£o de parada (i = i + i)
for(i = 1;              i <= 5;                i++){                               valor in√≠cio ‚Ü≤   ‚Ü≥ passo
    console.log("i: ", i)
}

 *A cada itera√ß√£o, "i" recebe um novo valor:

- Inicializa√ß√£o -> i = 1 (i++ -> i = i + 1)
- 1¬∫ incremento:
   i = 1 + 1 -> i = 2
- 2¬∫ incremento (repeti√ß√£o da condi√ß√£o i++ -> i = i + 1):
   i = 2 + 1 -> i = 3
- 3¬∫ incremento (repeti√ß√£o da condi√ß√£o i++ -> i = i + 1):
   i = 3 + 1 -> i = 4
- 4¬∫ incremento (repeti√ß√£o da condi√ß√£o i++ -> i = i + 1):
   i = 4 + 1 -> i = 5
- Assim suscetivamente at√© satisfazer a condi√ß√£o, ou seja, ir√° repetir o passo da instru√ß√£o at√© que o valor de "i"
seja igual ao valor de parada (=5).

1¬™ itera√ß√£o: i = 1
              ‚Ü± var     ‚Ü± n¬∫ de passos
2¬™ itera√ß√£o: (i = 1) + (i = 1) -> i = 2
3¬™ itera√ß√£o: (i = 2) + (i = 1) -> i = 3
4¬™ itera√ß√£o: (i = 3) + (i = 1) -> i = 4
5¬™ itera√ß√£o: (i = 4) + (i = 1) -> i = 5

>>>> COMBINANDO ESTRUTURAS: CONDICIONAIS + REPETI√á√ÉO

programa{
  funcao inicio(){
    caracter rodar

    enquanto(rodar != 'n'){
    
    inteiro opcao, numero, resultado, i
    caracter alternativa

    escreva("Escolha:\n1 - WHILE\n2 - DO-WHILE\n3 - FOR\n>> ")
    leia(opcao)

    enquanto(opcao < 1 ou opcao > 3){
      escreva("Escolha 1, 2 ou 3: ")
      leia(opcao)
    }

    escolha(opcao){
      caso 1:
        escreva("\n----- TABUADA WHILE -----\n")
        escreva("Digite um n√∫mero: ")
        leia(numero)
        enquanto(numero <= 0 ou numero > 10){
          escreva("N√∫mero inv√°lido, digite outro n√∫mero: ")
          leia(numero)
        }
        escreva("C - Crescente\nD - Decrescente\n>> ")
        leia(alternativa)
        se(alternativa == 'C' ou alternativa == 'c'){
          i = 1
          enquanto(i <= 10){
            resultado = numero * i
            escreva(numero, " x ",  i, " = ", resultado, "\n")
            i++
          }
        }se(alternativa == 'D' ou alternativa == 'd'){
          i = 10
          enquanto(i > 0){
            resultado = numero * i
            escreva(numero, " x ",  i, " = ", resultado, "\n")
            i--
          }
        }se(alternativa != 'C' e alternativa != 'c' e alternativa != 'D' e alternativa != 'd'){
          escreva("ALTERNATIVA INV√ÅLIDA\n")
        }
      pare
      caso 2:
        escreva("\n----- TABUADA DO-WHILE -----\n")
        escreva("Digite um n√∫mero: ")
        leia(numero)
        enquanto(numero <= 0 ou numero > 10){
          escreva("N√∫mero inv√°lido, digite outro n√∫mero: ")
          leia(numero)
        }
        escreva("C - Crescente\nD - Decrescente\n>> ")
        leia(alternativa)
        se(alternativa == 'C' ou alternativa == 'c'){
          i = 1
          faca{
            resultado = numero * i
            escreva(numero, " x ",  i, " = ", resultado, "\n")
            i++
          }enquanto(i <= 10)
        }se(alternativa == 'D' ou alternativa == 'd'){
          i = 10
          faca{
            resultado = numero * i
            escreva(numero, " x ",  i, " = ", resultado, "\n")
            i--
          }enquanto(i > 0)
        }se(alternativa != 'C' e alternativa != 'c' e alternativa != 'D' e alternativa != 'd'){
          escreva("ALTERNATIVA INV√ÅLIDA\n")
        }
      pare
      caso 3:
        escreva("\n----- TABUADA FOR -----\n")
        escreva("Digite um n√∫mero: ")
        leia(numero)
        enquanto(numero <= 0 ou numero > 10){
          escreva("N√∫mero inv√°lido, digite outro n√∫mero: ")
          leia(numero)
        }
        escreva("C - Crescente\nD - Decrescente\n>> ")
        leia(alternativa)
        se(alternativa == 'C' ou alternativa == 'c'){
          para(i = 1; i <= 10; i++){
            resultado = numero * i
            escreva(numero, " x ",  i, " = ", resultado, "\n")
          }
        }se(alternativa == 'D' ou alternativa == 'd'){
          para(i = 10; i > 0; i--){
            resultado = numero * i
            escreva(numero, " x ",  i, " = ", resultado, "\n")
          }
        }se(alternativa != 'C' e alternativa != 'c' e alternativa != 'D' e alternativa != 'd'){
          escreva("ALTERNATIVA INV√ÅLIDA\n")
        }
      pare
    }

    escreva("\nDeseja realizar uma nova opera√ß√£o? ")
    leia(rodar)
    se(rodar == 'n'){
      escreva("----- PROGRAMA ENCERRADO -----")
    }senao{escreva("\n")}
    }
  }

}
</pre>

##### QUEBRA DE CICLOS DE REPETI√á√ÉO
 As vezes √© necess√°rio interromper a execu√ß√£o de um ciclo de repeti√ß√£o em algum ponto do bloco de instru√ß√µes que est√° sendo repetido. Embora seja desencorajado realizar interrup√ß√µes dessa maneira ao inv√©s de usar as vari√°veis de controle, logicamente, seu uso depender√° se alguma condi√ß√£o for verdadeira ou n√£o. A interrup√ß√£o pode ser feita de 2 maneiras:

 1. Abandona e sai do ciclo de repita√ß√£o (`break`);
 2. Abandona a atual itera√ß√£o (*"pula uma repeti√ß√£o"*) e continua a pr√≥xima (`continue`).

 Ambos podem ser usados para quebrar qualquer loop. Quando o comando `break` √© usado dentro de um loop `for` por exemplo, o *indice* do loop √© ret√©m fora do loop seu √∫ltimo valor atribu√≠do.

```JS
let text = '';

for (let i = 0; i < 20; i++) {
  if (i === 3) {
    continue; // output: "012456789" <- skip 3
  } else if (i > 10) {
    break; // output: i = 10 <- stop 10
  }
  text = text + i;
}

console.log(`${text} - ${i}`); // output: 012456789 - 10
```

### FUN√á√ïES
 *"Subalgoritmo", "bloco", "m√©todo", "fun√ß√£o", "subprograma", "subrotina"*... S√£o instru√ß√µes que realizam tarefas espec√≠ficas, s√£o trechos de c√≥digos com instru√ß√µes/objetivos espec√≠ficos que podem ser chamadas dentro do c√≥digo principal. Ajudam na decomposi√ß√£o e modulariza√ß√£o do algoritmo para torn√°-lo mais leg√≠vel.

#### Bloco de instru√ß√µes (c√≥digos), identificado por *nome* e *par√¢metros* ("assinatura")
  - *Defini√ß√£o*: Objetivo da fun√ß√£o
  - *Nome*: Essencial para chama-la no c√≥digo principal
  - *Invoca√ß√£o*: Quais objetos e bibliotecas est√° invocando
  - *Vari√°vel Local*: √â destru√≠da ap√≥s encerrar a fun√ß√£o
  - *Vari√°vel Global*: √â acessada dentro e fora da fun√ß√£o
<pre>
Exemplo fun√ß√£o m√©dia escolar:
programa{
  funcao inicio(){
    real nota1, nota2

    escreva("Digite a 1¬™ nota do aluno: ")
    leia(nota1)
    escreva("Digite a 2¬™ nota do aluno: ")
    leia(nota2)

    media(nota1, nota2)
  }

  funcao media(real nota1, real nota2){
    real media
    media = nota1 + nota2 / 2

    escreva("M√©dia do aluno: ", media)
  }
}
</pre>

## DESENVOLVIMENTO DE PROGRAMAS
Ao desenvolver um programa, podemos nos fazer perguntas como:

- *O programa segue uma programa√ß√£o modular?*
- *Ele tem uma estrutura b√°sica ou √© ca√≥tico?*
- *Os procedimentos e fun√ß√µes est√£o bem desenvolvidos?*

A principal raz√£o para usar um computador √© para resolver problemas (no sentido geral), ou, em outras palavras, processar informa√ß√µes para obter um resultado a partir de dados de entrada. Durante a hist√≥ria dos computados, a forma como os computadores s√£o programados sofreu grandes mudan√ßas. A pesquisa te√≥rica levou a um conjunto de princ√≠pios que formam o conhecimento central de uma metologia de programa√ß√£o. Isso consiste em obter *programas de qualidade*. Durante o desenvolvimento de programas, devemos seguir algumas boas pr√°ticas b√°sicas:

- *Estruturas com sequ√™ncia de passos tendo o objetivo bem definido.*
- *Fun√ß√µes que executam tarefas espec√≠ficas.*
- *Simplicidade no conjunto de opera√ß√µes que resultam em uma sucess√£o de finitas a√ß√µes.*

Tendo em mente que um programa ao longo da sua vida √© escrito apenas uma vez, mas lido, analisado e modificado muitas vezes, √© de grande import√¢ncia adotar t√©cnicas apropriadas de projeto e desenvolvimento. Isso pode ser avaliado no c√≥digo por meio de diferentes caracter√≠sticas:

- **A corretude** do programa; crit√©rio indispens√°vel, no sentido de que queremos obter programas coerentes que resolvam os problemas para os quais foram projetados.
- **A compreensibilidade** do c√≥digo; que inclui legibilidade e boa documenta√ß√£o, caracter√≠sticas que permitem maior facilidade e conveni√™ncia na manuten√ß√£o dos programas;
- **A efici√™ncia** da metodologia aplicada para a constru√ß√£o; que expressa os requisitos de mem√≥ria e tempo de execu√ß√£o do programa.
- **A flexibilidade** na verifica√ß√£o e tratamento de exce√ß√µes; a capacidade do programa de se adaptar √†s varia√ß√µes do problema inicial.
- **A transportabilidade** no uso do software; que √© a possibilidade de usar o mesmo programa em sistemas diferentes sem fazer mudan√ßas significativas em sua estrutura.

S√£o necess√°rias 3 etapas principais para o desenvolvimento de um programa:
1. **AN√ÅLISE**: Primeiramente √© necess√°rio estudar o problema, definindo-se bem quais s√£o so dados a serem informados na entrada, como esses dados ser√£o processados e quais s√£o os dados de sa√≠da esperados. Depois de processados, os dados de entrada processados s√£o apresentados ao usu√°rio por meio dos dispositivos de sa√≠da. Essas informa√ß√µes s√£o importantes para que o objetivo do programa seja bem definido.
2. **ALGORITMO**: Ap√≥s a an√°lise e a identifica√ß√£o dos dados de entrada e sa√≠da, escreve-se o algoritmo, que, basicamente, √© o passo-a-passo da resolu√ß√£o do problema em quest√£o. Na constru√ß√£o do algoritmo, utilizamos a l√≥gica.
3. **CODIFICA√á√ÉO**: Nessa fase, o algoritmo criado deve ser codificado em uma linguagem de programa√ß√£o. A escolha da linguagem de programa√ß√£o depende do conhecimento do desenvolvedor, do tipo de aplicativo que vai ser desenvolvido ou at√© mesmo do local em que o aplicativo vai ser executado (na internet sem necessidade de download, ou instalado).
<pre>
-> An√°lise
- Estudo e defini√ß√£o dos
 dados de entrada e sa√≠da                                         -> Codifica√ß√£o
           ‚Üì                                                  ‚¨ê   - O algoritmo √© codificado de acordo com
  ------------------------       -----------     ------------      a linguagem de programa√ß√£o escolhida
 | Instru√ß√µes  Detalhadas | ->  | Algoritmo | -> | Programa |
  ------------------------       -----------     ------------
                        -> Algoritmo ‚§¥
                        - Descreve o problema por meio de ferramentas
                          narrativas, fluxogramas ou pseudo-c√≥digos
</pre>

### Como Construir um Algoritmo
  - *Compreens√£o do problema* -> Pontos mais importantes
  - *Defini√ß√£o dos dados de entrada* -> Dados fornecidos e cen√°rio
  - *Definir processamento* -> C√°lculos e restri√ß√µes
  - *Definir dados de sa√≠da* -> Resultados p√≥s processamento
  - *Utilizar um m√©todo de constru√ß√£o* -> Design de constru√ß√£o de algoritmo
  - *Teste e diagn√≥stico* -> Refinamento de algoritmo

### ESTRUTURA DE UM SOFTWARE E SEU AMBIENTE DE DESENVOLVIMENTO

Exemplo:<br/>
APP DE VIAGENS

features:
 1. solicitar ve√≠culo
 2. cadastrar usu√°rio
 3. cadastrar motorista
 <pre>
  __________________________________________________________________________________________
 |       FEATURE       |        INPUT         |        PROCESS       |        OUTPUT        |
 |---------------------|----------------------|----------------------|----------------------|
 |- CADASTRAR USU√ÅRIO  |- CLICAR NO BOT√ÉO:    |- VERIFICA SE CPF IN- |- MSG: "USU√ÅRIO CADAS-|
 |                     |   "ADD NEW USER"     |FORMADO POSSUI IRRE-  |TRADO COM SUCESSO!"   |
 |                     |                      |GULARIDADES           |                      |
 |                     |- DIGITAR: NOME, CPF, |                      |                      |
 |                     |  E CC                |- VALIDA CC           |                      |
 |---------------------|----------------------|----------------------|----------------------|
 |- SOLICITAR VE√çCULO  |- CLICAR NO BOT√ÉO:    |- VERIFICA MOTORISTAS |- MSG: "SEU MOTORISTA |
 |                     |  "SOLICITAR VIAGEM"  |MAIS PR√ìXIMOS NA RE-  |EST√Å A CAMINHO"       |
 |                     |                      |GI√ÉO                  |                      |
 |                     |- INSERIR DESTINO     |                      |- ATUALIZA TELA COM O |
 |                     |                      |- AO QUE ACEITAR, √â   |TEMPO ESTIMADO DE CHE-|
 |                     |                      |INFORMADO OS DADOS DA |GADA DO MOTORISTA     |
 |                     |                      |VIAGEM E DO PASSAGEIRO|                      |
 |                     |                      |                      |- EXIBE DADOS DO MOTO-|
 |                     |                      |                      |RISTA E DO VE√çCULO    |
 |---------------------|----------------------|----------------------|----------------------|
 |- CADASTRAR MOTORISTA|- CLICAR NO BOT√ÉO:    |- VERIFICA SE CPF E   |- MSG: "MOTORISTA CA- |
 |                     |  "SOLICITAR CADASTRO"|VE√çCULO POSSUEM IRRE- |DASTRADO COM SUCESSO!"|
 |                     |                      |GULARIDADES           |                      |
 |                     |- ADICIONA DADOS E    |                      |                      |
 |                     |INFORMA√á√ïES PESSOAIS  |                      |                      |
 |                     | E DO VE√çCULO         |                      |                      |
 |_____________________|______________________|______________________|______________________|
</pre>

### CONSTRU√á√ÉO DE ALGORITMOS
Para criar um algoritmo, podemos utilizar diferentes representa√ß√µes, sejam elas textuais ou gr√°ficas. A escolha pela forma de representa√ß√£o depende do n√≠vel de detalhamento que se quer dar ao algoritmo.
1. **DESCRI√á√ÉO NARRATIVA**: √â a forma mais simples de representar um algoritmo. Os passos executados s√£o descritos em linguagem natural. Essa representa√ß√£o, no entanto, n√£o √© muito utilizada porque a linguagem natural pode dar oportunidade a interpreta√ß√µes incorretas, ambiguidades e imprecis√£o. Por n√£o se ter regras, limites e nem um padr√£o bem definido, algumas pessoas s√£o capazes de detalhar bem os passos, outras pessoas n√£o.
2. **FLUXOGRAMA**: Utiliza s√≠mbolos de formas geom√©tricas padronizadas com significados bem definidos para representar os diferentes passos a serem executados, tamb√©m chamados de *comandos*. O fluxograma possibilita uma representa√ß√£o mais precisa, detalhada e menos abstrata que a descri√ß√£o narrativa.
3. **PSEUDOC√ìDIGO**: Aqui se tem a padroniza√ß√£o do fluxograma e a facilidade de texto da descri√ß√£o narrativa, criando algoritmos estruturados. Consiste em uma representa√ß√£o textual simplificada de um algoritmo, utilizando uma linguagem intermedi√°ria entre a linguagem natural e uma linguagem de programa√ß√£o. No pseudoc√≥digo, s√£o utilizados comandos e estruturas l√≥gicas semelhantes √†s encontradas em linguagens de programa√ß√£o, mas sem a necessidade de respeitar a sintaxe rigorosa dessas linguagens. Essa abordagem permite que o algoritmo seja entendido de forma clara e padronizada, facilitando sua implementa√ß√£o posterior em uma linguagem de programa√ß√£o.

#### BOAS PR√ÅTICAS
- **Indenta√ß√£o**: Uma pr√°tica sempre recomendada, ligada √† limpeza e utilizada para facilitar a leitura do c√≥digo, √© o uso correto de recuos, ou indenta√ß√£o. Deve-se alinhar elementos "irm√£os" na mesma margem e adicionar alguns espa√ßos ou um tab para elementos "filhos".
- **Coment√°rios**: Quando iniciamos um projeto, pouco c√≥digo √© escrito. Mais tarde adicionaremos uma quantidade razo√°vel de elementos, o que pode gerar uma certa confus√£o. Para manter o c√≥digo mais leg√≠vel, √© recomendada a adi√ß√£o de coment√°rios √† cada se√ß√£o do c√≥digo. Dessa maneira, √© poss√≠vel identificar claramente o objetivo de cada parte do script.

<pre>
                       / - Sem conceitos novos
Narrativa             ‚ùÆ  - Utiliza√ß√£o de linguagem natural em forma de texto estruturado
(Descritiva)           \ - Podem haver diversas interpreta√ß√µes poss√≠ves (ambiguidade)

1. receba os dados
2. trate os dados
3. decida com base nos dados
4. exiba o resultado/dados

                       / - F√°cil entendimento
Fluxograma            ‚ùÆ  - Utiliza√ß√£o de s√≠mbolos pr√©-definidos para representa√ß√£o visual de uma sequ·∫Ωncia de a√ß√µes l√≥gicas
(estrutura gr√°fica)    \ - Necess√°rio conhecimento pr√©vio da estrutura e s√≠mbolos

Estrutura e s√≠mbolos:
    _____
   (_____) -> IN√çCIO/FIM
    __‚Üì__
   /____/  -> ENTRADA DE DADOS
      ‚Üì
     / \   -> ESTRUTURA DE DECIS√ÉO
     \ /
    __‚Üì__
   |_____|  -> ATRIBUI√á√ÉO / A√á√ÉO / RESULTADO DA DECIS√ÉO / OPERA√á√ÉO
      ‚Üì  ___
‚ùÆ...) ~ |...| -> RESULTADO OPERA√á√ÉO
         ~~~
    __‚Üì__
   /_____\  -> SA√çDA DE DADOS

                      / - Regras pr√©-definidas
Pseudo-C√≥digo        ‚ùÆ  - Passos a serem seguidos
                      \ - Pseudo-linguagem de programa√ß√£o

programa {
  funcao inicio() {
    var dados
    escreva("INSIRA OS DADOS\n")
    leia(dados)
    escreva("resultado:", tratamento_de_dados(dados))
  }

  tratamento_de_dados(var dados) {
    var dados
    escreva("dados tratados")
  }
}
</pre>

**Exemplos de constru√ß√£o de algoritmos:**
<pre>
1. Multiplica√ß√£o de 2 n¬∫s

            /  Passo 1 - Recebe os valores
Narrativa  ‚ùÆ   Passo 2 - Multiplica
            \  Passo 3 - Imprime o resultado

            ___ 
           |    (START)  ‚ûù  /N1, N2/
           |                   ‚Üì
Fluxograma-|              [M = N1 * N2]
           |                   ‚Üì
           |                  |M|
           |                   ~
           |                   ‚Üì
           |___              (END)

Pseudo-C√≥digo ‚ùÆ N1 * N2 = M

2. Contagem de Intervalos de N√∫meros entre 1 e 200

2.1. Como analisar os padr√µes?

1 + 2 \                |   200 + 1 \  Decrementar o maior
1 + 3  \ Inefici√™nte   |   199 + 2  \         +
1 + 4  /               |   198 + 3  / Encrementar o menor
1 + 5 /                |   197 + 4 /
                              ‚Üô                              / 200 + 1 = *201*
                      Qual o benef√≠cio?  ->  Gera um PADR√ÉO ‚ùÆ  199 + 2 = *201*
                        DECOMPOSI√á√ÉO                         \ 198 + 3 = *201*

2.2. Como expressar de forma generalista?
  ‚¨ê dcmps ‚¨é ‚¨ê padr√£o
| 200 + 1 = 201 |         /  Valor  \   SIM      ABSTRA√á√ÉO     Podemos expressar atrav√©s de vari√°veis,
| 199 + 2 = 201 |   ->   ‚ùÆ    se     ‚ùØ   ->    ‚ùÆ Qnts vzs? ‚ùØ = para tornar uma soma de intervalos espec√≠fico
| 198 + 3 = 201 |         \ Repete? /                          para algo mais generalista, onde essa mesma
                                                     ‚Üì         solu√ß√£o pode ser aplicada em outros cen√°rios
                                                               similares a este.
                                      Em um intervalo de *200* n√∫meros
                                      onde usamos sempre *2* n√∫meros a
                                      cada soma, podemos dividir um n¬∫
                                       pelo outro para encontrarmos o
                                        valor da quantidade de vezes
                                        em que este processo ocorre:
                                              | 200 / 2 = 100 |
                              Ent√£o, sabemos que encontraremos o resultado *201*
                              todas as *100* vezes que realizarmos este processo
                                resultando em 20.100 intervalos entre 1 e 200:
                                            |     resultado      |
                                            | 201 x 100 = 20.100 |
                                                      ~
2.3. Como expressar em vari√°veis?
((y / 2) * ((y - 1) + (x + 1)))

> [x = 1, y = 200] -> intervalo (1 e 200)
                    =
  (y - 1) + (x + 1) = resultado parcial
                    =
    (200 - 1 = 199) + (1 + 1 = 2) = 201
    (199 - 1 = 198) + (1 + 2 = 3) = 201
    (198 - 1 = 197) + (1 + 3 = 4) = 201
                   ...

> y / 2 = total
            ‚§∑ total      x     resultado parcial
          (200 / 2 = 100) * ((y - 1) + (x + 1) = 201)
                          =
                      resultado
                  100 * 201 = 20.100

Algoritmo:

Passo 1. Recebe os valores (x e y)
Passo 2. Resolva: y/2 = total
Passo 3. Resolva: (y - 1) + (x + 1) = resultado parcial
Passo 4. resultado = total x resultado parcial
Passo 5. Imprima o resultado

C√≥digo:

programa{

  funcao inicio(){
    inteiro x = 1, y = 200
    escreva(soma_intervalo(x, y))
  }

  funcao soma_intervalo(inteiro x, inteiro y){
    inteiro total_intervalo, resultado_parcial, resultadoParcial
    
    total_intervalo = y / 2
    para(resultado_parcial = 1; resultado_parcial <= y; resultado_parcial++) {
      resultadoParcial = ((y - 1) + (x + 1))
      escreva(resultadoParcial, " - ", resultadoParcial, "\n")
    }

    inteiro resultado = total_intervalo * resultadoParcial

    retorne resultado
  }
}

3. Adivinhe o n√∫mero
 O problema consiste em determinar o n√∫mero escolhido por uma pessoa dentro de um intervalo,
usando perguntas com respostas de "sim" e "n√£o".

> Busca por varredura:

- O n√∫mero √© 1? \ 
- O n√∫mero √© 2?  ‚ùØ Inefici√™nte
...             /

> Busca Bin√°ria:

- P: O n√∫mero √© maior que 50? \ 
- R: N√£o                       \ 
- P: O n√∫mero √© menor que 20?   ‚ùØ N¬∫ menor de tentativas
- R: Sim                       /
...                           /

Algoritmo:

Passo 1. Ordenar o vetor
Passo 2. M√≥dulo de L/2 (L = tamanho do vetor)
Passo 3. Acessar estrutura
Passo 4. Repita at√© encontrar o n√∫mero
Passo 5. Imprima o resultado

C√≥digo:

programa{
  funcao inicio(){
    escreva("--- ADIVINHE O N√öMERO ---")

    recomecar:

    escreva("Digite um n√∫mero: ")
    cin >> adivinha;

    se(adivinha == 9 || adivinha == 10){
      escreva("Parab√©ns! Voc√™ acertou!")
    }senao(adivinha >=5 && adivinha < 9 || adivinha > 10 && adivinha < 13){
      escreva("Est√° perto, tente novamente!")
      vapara recomecar;
    }outro{
      escreva("Tente denovo!\n")
      vapara recomecar;
    }
  }
}
</pre>
 Exemplo pr√°tico:<br/>
 Uma pessoa tem um or√ßamento limitado para gastar no mercado, como isso pode ser resolvido de forma simples com algoritmo?

```Py
# algoritmo
orcamento = float(input("OR√áAMENTO: "))
total_gasto = 0
decisao = ''

while decisao != 'N' and decisao != 'n':

  valor = float(input("\nValor do item: "))
  qntd = int(input("\nQntd do item: "))

  total_gasto += valor * qntd

  decisao = input("\nOutro item (S/N): ")

if total_gasto > orcamento:
  print("\n\nSALDO INSUFICIENTE\nor√ßamento: ", orcamento, "\ntotal: ", total_gasto, "\nfaltam: ", total_gasto - orcamento)
elif total_gasto <= orcamento:
  print("\n\nCOMPRA EFETIVADA", orcamento, "\ntotal: ", total_gasto, "\ntroco: ", orcamento - total_gasto)
```

###### CRIANDO UM PROGRAMA

**M√©dia Escolar**<br/>
Uma diretora decide fazer um programa para saber qual a m√©dia dos alunos da escola:
- O m√©todo de avalia√ß√£o utilizado por cada professor pode ser diferente, mas todos os m√©todos resultam em uma nota final.
- A nota dos alunos √© uma abstra√ß√£o. Podemos n√£o saber exatamente qual o m√©doto utilizado para gerar a nota de cada aluno diferente, mas astraimos isso e extraimos a informa√ß√£o mais importante que √© comum a todos: a nota.
<pre>
             / Passo 1 - Recebe os valores
            /  Passo 2 - Calcula a m√©dia
Narrativa  ‚ùÆ   Passo 3 - Imprime o resultado
            \  Passo 4 - Regra de aprova√ß√£o
             \ Passo 5 - Imprime o resultado

            ____
           |     (START) ‚ûù /N1, N2/
           |                   ‚Üì
Fluxograma-|          [M = (N1 * N2) / 2]
           |                   ‚Üì
           |                  |M|
           |                   ~
           |             YES   ‚Üì    NO
           |   |APROVADO| ‚üµ &lt;M ‚â• 6&gt; ‚ü∂ |REPROVADO|
           |                   ‚Üì
           |____             (END)

Prot√≥tipo:

algoritmo "media"
  var
    recuperacao, soma, media, nota, qntd, armazenamento: real
    calcular, aluno: caractere
  inicio
    escreva("Digite o nome do Aluno: ")
    leia(aluno)
    escreva("Quantas notas ser√£o? ")
    leia(qntd)
    escreval()
      enquanto armazenamento < qntd faca
        escreva("Digite uma nota: ")
        leia(nota)
        soma <- nota + soma
        armazenamento <- armazenamento + 1
      fimenquanto
    media <- soma/qntd
    escreval()
    escreva("M√©dia do aluno :", media)
    escreval()
    se(media >= 7) entao
      escreva("ALUNO APROVADO!")
      escreval()
      escreval()
    senao
      armazenamento <- armazenamento + 1
      escreval()
      escreva("ALUNO DE RECUPERA√á√ÉO!")
      escreval()
      escreva("Digite a nota da recupera√ß√£o: ")
      leia(recuperacao)
      media <- (soma+recuperacao)/armazenamento
      se(media >= 7) entao
        escreval()
        escreva("ALUNO APROVADO!")
        escreval()
        escreva("M√©dia do aluno: ", media)
        escreval()
        escreval()
      senao
        escreval()
        escreva("ALUNO REPROVADO!")
        escreval()
        escreva("M√©dia do aluno: ", media)
        escreval()
        escreval()
      fimse
    fimse
fimalgoritmo
</pre>

```Python
# teste prot√≥tipo
notas = int(input("Quantas notas voce vai digitar? ")) # 2
notas_aluno = [float(input(f"Digite a {i+1}¬™ nota: ")) for i in range(notas)]
media = sum(notas_aluno) / len(notas_aluno)
print(f"media = {media:.2f}") # 6.0

if media >= 6.0:
    print('Aprovado')
else:
    print('Reprovado') # Aprovado
```

###### REFATORANDO
<pre>
programa{
    funcao inicio() {
        real notas[5]
        inteiro parada

        escreva("Quantas notas ser√£o? ")
        leia(parada)

        para(inteiro i = 0; i < parada; i++) {
          inteiro nota
          escreva("Digite a ", i + 1, "¬™ nota: ")
          leia(nota)
          notas[i] = nota
        }
      escreva("M√©dia do aluno: ", media(notas, parada))
    }

    funcao real media(real notas[], inteiro parada) {
        real soma = 0

        para(inteiro i = 0; i < parada; i++) {
          soma = soma + notas[i]
        }
      real media = soma / parada
      retorne media
    }
}
</pre>

```Python
def calcular_media(notas):
    return sum(notas) / len(notas)

def main():
    notas = []
    parada = int(input("Quantas notas ser√£o? "))

    for i in range(parada):
        nota = float(input(f"Digite a {i+1}¬™ nota: "))
        notas.append(nota)

    media = calcular_media(notas)
    print("M√©dia do aluno:", media)

if __name__ == "__main__":
    main()
```

###### EXTRA
[aprofundando nos conceitos de desenvolvimento de softwares](https://github.com/raphaelkaique1/study/blob/main/1-fundamentos_de_computacao/1.1-conceitos_basicos/segmentacao_da_programacao.pdf)

###### MANUTEN√á√ÉO: COMENT√ÅRIOS E ESTRUTURA DO SCRIPT
 Os coment√°rios de c√≥digo s√£o bastante √∫teis, por√©m n√£o s√£o confi√°veis. Muitas vezes, os desenvolvedores atualizam o c√≥digo mas esquecem de atualizar os coment√°rios. *Deve-se usar coment√°rios apenas para ideias de n√≠vel superior (de alguma forma, padronizados no escopo do projeto) e n√£o adicionar comet√°rios sobre como uma linha de c√≥digo indivual funciona (pois n√£o explicativos o suficiente - explicam apenas como o c√≥digo executa as a√ß√µes √≥bvias que foram feitos para fazer, mas n√£o explicam o conceito para o qual aquele trecho foi desenvolvido - e "sujam" o c√≥digo, tornando dif√≠cil entender sua l√≥gica de execu√ß√£o)*. Em conjunto, *um c√≥digo leg√≠vel √© constru√≠do declarando nomes de vari√°veis, fun√ß√µes e afins de forma que seu prop√≥sito esteja expl√≠cito, quanto mais descrit√≠vo, maior a legibilidade do c√≥digo*, o tornando **auto-comentado**. Al√©m disso, a estrutura de como o script do c√≥digo √© feita no arquivo ajuda em muito aumentar a flu√™ncia e o entendimento da l√≥gica do c√≥digo, mantendo as linhas em contextos semelhantes juntas e adicionando quebras de linha (espa√ßos em branco) para separar blocos e aumentar a "√°rea de campo limpa".<br/>
 A utilidade de um coment√°rio √© subjetiva. Em todos os assuntos relacionados √† legibilidade do c√≥digo, use o bom senso. Fa√ßa aquilo que consdierar ser o melhor para aumentar a clareza do c√≥digo.

### LINGUAGENS DE PROGRAMA√á√ÉO
 Uma linguagem de programa√ß√£o √© um sistema com uma estrutura de comunica√ß√£o semelhante √† humana que permite que os dispositivos se entendam e interpretem e executem as instru√ß√µes do usu√°rio. A linguagem de programa√ß√£o √© a transforma√ß√£o de uma ideia, estruturada com racioc√≠nio l√≥gico utilizando l√≥gica de programa√ß√£o, para criar um algoritmo, que, atrav√©s de uma linguagem de programa√ß√£o - que possui seu pr√≥prio conjunto de s√≠mbolos e comandos - define atrav√©s de instru√ß√µes, um programa de computador escrito em c√≥digo fonte e traduzido para linguagem de m√°quina, para ser executada por algum equipamento e realizar a tarefa a qual foi designada. A programa√ß√£o √© um conjunto de instru√ß√µes ordenadas e sucessivas destinadas a executar uma tarefa espec√≠fica. Estas instru√ß√µes s√£o chamadas de "c√≥digo fonte", que s√£o exclusivas para cada idioma e s√£o projetadas para cumprir uma fun√ß√£o espec√≠fica. As linguagens de programa√ß√£o t√™m um vocabul√°rio que √© regido por um conjunto de regras gramaticais que utilizam uma sintaxe que, neste caso, nos permite dar instru√ß√µes concretas a uma m√°quina e para que ela as interprete. A programa√ß√£o √© o processo de an√°lise, projeto, implementa√ß√£o, teste e depura√ß√£o de um algoritmo, a partir de uma linguagem que gera um c√≥digo fonte executado no computador. Ou seja, uma linguagem de programa√ß√£o √© um m√©todo composto por um conjunto de regras sint√°ticas e sem√¢nticas para implementa√ß√£o de um c√≥digo fonte. A principal fun√ß√£o das linguagens de programa√ß√£o √© escrever programas que permitam a comunica√ß√£o usu√°rio-m√°quina.

```C
#include <stdio.h>

int main() {
  int x, y;

  printf("Digite um n√∫mero inteiro: ");
  scanf("%d", &x);
  printf("Digite outro n√∫mero inteiro: ");
  scanf("%d", &y);
  if(x > y) {
    printf("O maior valor √© %d.\n", x);
  } else {
    printf("O maior valor √© %d.\n", y);
  }
  return 0;
}
```

### SINTAXE E SEM√ÇNTICA
 As instru√ß√µes de uma linguagem de programa√ß√£o devem obedecer as regras de escrita definidas, s√£o chamadas essas regras de: sintaxe e sem√¢ntica, (assim como ocorre tamb√©m na linguagem natural). Sintaxe √© como aprender a escrever palavras corretamente em uma l√≠ngua, enquanto a sem√¢ntica trata de como usar essas palavras para formar frases que fazem sentido.
- **SINTAXE**: √â o *"como"* escrever o c√≥digo; √â a forma como as instru√ß√µes de uma linguagem s√£o escritas. Refere-se ao conjunto de regras que define a estrutura e o formato v√°lido para escrever c√≥digo em uma linguagem de programa√ß√£o. √â como a *"gram√°tica"* de uma linguagem. Exemplo em Python:

```Py
  print("Hello world!")
```
 O c√≥digo acima segue a sintaxe correta do Python para imprimir uma mensagem no console, visto que a mensagem est√° dentro de aspas e par√™nteses, ou seja, a simbologia para que a impress√£o da mensagem na tela aconte√ßa est√° coerente com o que se espera nessa linguagem. No entanto, se escrevermos algo como:
```Py
  print "Hello world!"
```
 Apesar da sem√¢ntica estar correta (que tem como finalidade realizar a sa√≠da dos dados usando a instru√ß√£o `print()`), iremos receber uma mensagem de erro de sintaxe porque faltam os par√™nteses ao redor da mensagem. Os mais comuns erros de sintaxe s√£o relacionados √† escrita: a falta de s√≠mbolos obrigat√≥rios (como par√™nteses, ponto-e-v√≠rgula, v√≠rgulas, endenta√ß√£o e etc), palavras reservadas escritas incorretamente, estruturas de c√≥digo mal formatadas, entre outros.
- **SEM√ÇNTICA**: √â a *"organiza√ß√£o"* do c√≥digo, ou seja, O QUE o c√≥digo faz; Complementar √† sintaxe, corresponde √† descri√ß√£o do significado das instru√ß√µes v√°lida de uma linguagem. Refere-se ao significado/comportamento do c√≥digo, √© o que garante que o c√≥digo fa√ßa o que se espera dele, ou seja, que ele tenha l√≥gica e funcione corretamente. Como:
```Py
  resultado = 10 / 2 # divis√£o v√°lida
```
 Esse c√≥digo tem uma sem√¢ntica correta, j√° que a opera√ß√£o de divis√£o √© v√°lida. No entanto, considerando se vissemos algo assim:
```Py
resultado = 10 / 0 # divis√£o inv√°lida
```
 Apesar de a sintaxe estar correta, a sem√¢ntica est√° errada, porque dividir por zero n√£o √© permitido, gerando um erro l√≥gico durante a execu√ß√£o.
 <pre>
     	                            SINTAXE                             SEM√ÇNTICA
 Pergunta-chave     	 "Est√° escrito corretamente?"	                "Faz sentido?"
 Erro	                 O programa n√£o ser√° executado     O programa √© executado, mas pode falhar
                           (erro de compila√ß√£o).             ou produzir resultados errados.
 Foco	                 Estrutura e formato do c√≥digo.        Significado e l√≥gica do c√≥digo.
</pre>

### ESTRUTURA DE TIPOS
 Refere-se ao sistema que uma linguagem de programa√ß√£o utiliza para definir, manipular e verificar os tipos de dados. Ela estabelece como os tipos s√£o tratados e como as convers√µes entre tipos s√£o realizadas. A estrutura de tipos pode influenciar diretamente a flexibilidade, a seguran√ßa e a facilidade de uso da linguagem.

#### SISTEMAS DE TIPOS
 O sistema de tipos define como diferentes tipos de dados s√£o representados e como podem ser combinados. Ele inclui:
 - *Defini√ß√£o de Tipos*: Como os tipos de dados s√£o declarados e definidos (por exemplo, inteiros, strings, listas).
 - *Verifica√ß√£o de Tipos*: Como a linguagem garante que as opera√ß√µes sobre vari√°veis e express√µes sejam realizadas com tipos compat√≠veis.
 - *Convers√£o de Tipos*: Como e quando os tipos podem ser convertidos entre si (convers√µes impl√≠citas ou expl√≠citas).

##### CLASSIFICA√á√ïES DOS SISTEMAS DE TIPOS
 A estrutura de tipos pode ser classificada de v√°rias maneiras, incluindo:
 - *Tipagem Fraca*: A linguagem permite convers√µes impl√≠citas entre tipos diferentes. Pode levar a ter comportamentos inesperados devido a convers√µes autom√°ticas.
 - *Tipagem Forte*: A linguagem exige que as convers√µes entre tipos sejam feitas explicitamente, o que ajuda a evitar erros de tipo.
 - *Tipagem Din√¢mica*: O tipo de uma vari√°vel √© determinado em tempo de execu√ß√£o. Isso permite maior flexibilidade, mas pode resultar em erros de tipo que s√≥ s√£o detectados quando o c√≥digo √© executado.
 - *Tipagem Est√°tica*: O tipo de uma vari√°vel √© definido em tempo de compila√ß√£o e n√£o pode ser alterado durante a execu√ß√£o. Isso ajuda a detectar erros de tipo mais cedo, geralmente durante a compila√ß√£o.

##### ESTRUTURAS DE TIPOS ESPEC√çFICAS
 Al√©m da tipagem geral, existem estruturas e conceitos espec√≠ficos associados a tipos:
 - *Tipos Primitivos*: Tipos b√°sicos fornecidos pela linguagem, como inteiros, caracteres e booleanos.
 - *Tipos Compostos*: Tipos formados por combina√ß√£o de tipos primitivos, como arrays, listas, ou structs.
 - *Tipos Abstratos*: Tipos definidos pelo usu√°rio que podem encapsular dados e opera√ß√µes, como classes e interfaces em linguagens orientadas a objetos.
 - *Polimorfismo*: A capacidade de uma fun√ß√£o ou opera√ß√£o atuar sobre diferentes tipos de dados de maneira uniforme, muitas vezes implementada atrav√©s de generics ou templates.

#### GRAU DE ABSTRA√á√ÉO
 Uma linguagem de programa√ß√£o pode ser de BAIXO N√çVEL ou de ALTO N√çVEL. Assim como nas linguagens naturais existem seus vocabul√°rios com regras, na linguagem de programa√ß√£o n√£o √© diferente, √© preciso que exista um termo (comando) que solicite a entrada de dados, outro para solicitar a sa√≠da de dados e assim por diante. Assim como as linguagens naturais se diferenciam por idiomas, tamb√©m s√£o diferenciadas as linguagens de programa√ß√£o, e, dependendo da linguagem escolhida para se criar um programa, ela pode ser muito pr√≥xima da linguagem natural, mas isso significa que ser√° necess√°rio traduzi-la para a linguagem compreendida pelo computador. A linguagem de baixo n√≠vel (ou linguagem de m√°quina) √© uma linguagem muito pr√≥xima da linguagem bin√°ria (que √© o que o computador entende), linguagens de baixo n√≠vel d√£o maior controle sobre o hardware, por isso, e tamb√©m pela sua sint√°xe complexa e de dif√≠cil leitura, torna-se bem complexo o uso de linguagens desse tipo (a depender da tarefa a ser executada). J√° as linguagens de alto n√≠vel apresentam uma sint√°xe mais pr√≥xima da linguagem humana, cont√©m palavras reservadas extra√≠das do vocabul√°rio corrente (geralmente em ingl√™s) e por isso possuem um desenvolvimento de programas mais r√°pido. Cada linguagem √© melhor indicada para cada categoria de problemas espec√≠ficos, e definimos qual linguagem usar para a resolu√ß√£o do problema em quest√£o atrav√©s do grau de abstra√ß√£o. O grau de abstra√ß√£o funciona como uma escala para linguagens: quanto mais abaixo, mais pr√≥ximo da linguagem de m√°quina, e quanto mais alto, mais pr√≥ximo est√° da linguagem humana. Existem 3 tipos de grau de abstra√ß√£o:
 1. **Baixo N√≠vel**: Possui s√≠mbolos que representam o c√≥digo de m√°quina propriamente. Sua concep√ß√£o √© menos flex√≠vel, ou seja, a torna mais espec√≠fica ao tipo de sistema para que foi escrita, √© usada para controlar diretamente o hardware do dispositivo para tirar o m√°ximo de proveito dos componentes, n√£o sendo poss√≠vel (ou t√£o facilmente) migrada e executada em outros dispositivos al√©m do qual foi originalmente criada, por ser exclusivamente dependente da arquitetura da m√°quina. Elas s√≥ podem comandar as opera√ß√µes prim√°rias para a opera√ß√£o do dispositivo e tendem a ser complexas, raz√£o pela qual s√£o frequentemente utilizados pelos fabricantes de hardware. Com esta linguagem de programa√ß√£o de baixo n√≠vel √© poss√≠vel reproduzir √°udio e v√≠deo, exibir imagens, realizar opera√ß√µes matem√°ticas, seguir o movimento do ponteiro, manipular a mem√≥ria, e etc. Dentro deste grupo est√£o:
    - **1.1 Linguagem de M√°quina**: Essa linguagem comanda a m√°quina para realizar as opera√ß√µes que s√£o fundamentais para seu funcionamento. Consiste na combina√ß√£o de 0's e 1's para formar os comandos compreens√≠veis pelo hardware. Este idioma tem uma velocidade de execu√ß√£o muito superior aos idiomas de alto n√≠vel.
    - **1.2 Linguagem de Montagem**: √â um derivado da linguagem de m√°quina e √© composto por abrevia√ß√µes de letras e n√∫meros chamados de *"mnem√¥nicos"* (mnemonics = relativo √† mem√≥ria). Os mnem√¥nicos s√£o instru√ß√µes simb√≥licas que representam comandos espec√≠ficos que o processador pode executar. Eles servem para simplificar a escrita do c√≥digo em compara√ß√£o com a utiliza√ß√£o direta de n√∫meros bin√°rios ou hexadecimais que o hardware entende. Com o aparecimento desta linguagem, foram criados programas de tradu√ß√£o para converter programas escritos em linguagem de montagem em linguagem de m√°quina. Uma vantagem sobre o c√≥digo da m√°quina √© que os c√≥digos-fonte eram mais curtos e os programas criados ocupavam menos mem√≥ria.
 2. **M√©dio N√≠vel**: Possui s√≠mbolos que podem ser diretamente traduz√≠veis para c√≥digo de m√°quina, mas tamb√©m possui s√≠mbolos que precisam ser processados por um compilador. Ou seja, s√£o linguagens muito pr√≥ximas da linguagem natural, mas com um poder de acesso ao kernel maior do que linguagens propriamente de n√≠vel mais alto, por serem  "interpretadas" para linguagens de baixo n√≠vel. Permitindo opera√ß√µes de alto n√≠vel enquanto fazem a gest√£o local da arquitetura do hardware do sistema. Eles s√£o necess√°rios  para certas aplica√ß√µes como a cria√ß√£o de sistemas operacionais, pois permitem um manuseio abstrato (independente da m√°quina, ao contr√°rio do montador), mas sem perder muito da pot√™ncia e efici√™ncia das linguagens de baixo n√≠vel.
 3. **Alto N√≠vel**: Possui s√≠mbolos complexos que necessitam da interpreta√ß√£o de um compilador para que sejam transformados em linguagem de m√°quina. Tratam-se de linguagens com prop√≥sitos universais, s√£o executadas em plataformas (n√£o diretamente pelo hardware do sistema) o que permite maior flexibilidade de uso pois seus comandos s√£o intepretados para que possam ser executados por qualquer sistema j√° que s√£o independentes da arquitetura inform√°tica, assim, em princ√≠pio, um programa escrito em linguagem de alto n√≠vel pode ser migrado de uma m√°quina para outra sem qualquer problema.
<pre>
                                              LINGUAGEM QUE O
                    --------------         COMPUTADOR ENTENDE
  PROGRAMA          | COMPILA√á√ÉO |       E EXECUTA AS INSTRU√á√ïES
     ||             --------------                 ||
 LINGUAGEM DE =>     TRADU√á√ÉO PARA    =>       [ASSEMBLY]
  ALTO N√çVEL     LINGUAGEM DE M√ÅQUINA              ||
     ||            -----------------         PROGRAMA OBJETO
 C√ìDIGO FONTE      | INTERPRETA√á√ÉO |            EXECU√á√ÉO
                   -----------------
</pre>

### IMPLEMENTA√á√ïES DE LINGUAGEM<br/>TRADUTORES
S√£o programas especiais (compiladores ou int√©pretes) que converter instru√ß√µes escritas em c√≥digo fonte, para instru√ß√µes escritas em linguagem de m√°quina (bin√°rio - 0 e 1).
<pre>
COMPILA√á√ÉO   -\   1. Gera√ß√£o do programa objeto
(TRADU√á√ÉO)   -/   2. Execu√ß√£o do programa objeto

              ---/--
              --/---

INTERPRETA√á√ÉO => Programa fonte executado *"diretamente"*: l√™ a linha -> traduz -> executa
</pre>

#### COMPILA√á√ÉO
 O script de uma linguagem de programa√ß√£o √© traduzido em sua linguagem de m√°quina equivalente e ent√£o um programa execut√°vel √© obtido. Os tradutores do tipo compilador convertem o c√≥digo fonte de um programa em c√≥digo de m√°quina, gerando um recurso adicional, um arquivo contendo o progama traduzido, que ser√° usado para executar o programa.<br/>
 O programa fonte ser√° analisado pelo *comutador*, que verifica se ele foi escrito de acordo com as regras da linguagem de programa√ß√£o, em seguida convertido, frase por frase, em c√≥digo de m√°quina, criando um *programa objeto* ou *c√≥digo objeto*. Quem realiza este processo √© o *"pr√©-processador"*, ele se encarrega de incluir arquivos, expandir macros, remover coment√°rios e outras tarefas similares.<br/>
 Entretanto, para criar o programa final autoexecut√°vel, ser√° necess√°rio um processo adicional: *a liga√ß√£o (ou montagem) realizado pelo programa assembler, ou "linker"*.<br/>
 O linker √© um programa que constr√≥i o *arquivo execut√°vel*; adicionando ao *programa objeto* os cabe√ßalhos necess√°rios e as fun√ß√µes de biblioteca utilizadas pelo programa, ele leva os *arquivos objetos* gerados nas primeiras etapas do processo de compila√ß√£o (pelo pr√©-processador) e os recursos necess√°rios da(s) biblioteca(s), remove os processos e dados que n√£o s√£o necess√°rios e liga o c√≥digo √† biblioteca para aumentar seu tamanho e comprimento. O resultado final ser√° um programa auto-executador que n√£o precisar√° de nenhuma ferramenta adicional para faz√™-lo. Simplesmente solicitamos para *"rodar"* e ele o far√°.<br/>
 *Muitos compiladores, ao inv√©s de gerar c√≥digo objeto, geram um programa de linguagem assembly que deve ent√£o ser convertido em um execut√°vel por um programa assembly, execut√°vel por meio de um programa de montagem.<br/>
 **Vantagens**
 - R√°pida execu√ß√£o.
 - N√£o h√° necessidade de transmitir o c√≥digo fonte.
 - O c√≥digo compilado n√£o pode ser "aberto" por outros.
 - O c√≥digo compilado √© compactado em um √∫nico arquivo.
 - O processo de cria√ß√£o do execut√°vel √© feito apenas uma vez, tendo um arquivo pronto sempre a disposi√ß√£o para executar o programa.
 - Linguagens com maior efici√™ncia e poder de controle.
 **Desvantagens**
 - O c√≥digo compilado normalmente ocupa muito espa√ßo em disco, pois incorpora algumas bibliotecas do sistema no pr√≥prio c√≥digo.
 - O compilador trabalha em todo o programa uma √∫nica vez e o leva inteiro como entrada.
 - A depura√ß√£o de um programa envolve a recompila√ß√£o ap√≥s as mudan√ßas.
 - O compilador n√£o permite a execu√ß√£o de um programa at√© que ele esteja completamente livre de erros.
 - Os erros s√£o relatados depois que o programa inteiro √© verificado quanto √† sint√°ctica e outros erros.
 - Linguagens mais dif√≠ceis de depurar.
<pre>
C/C++, JAVA:
________________        _________        _________________
|PROGRAMA FONTE|   ->   |COMPILA|   =>   |PROGRAMA OBJETO|   =   EXECUTA O PROGRAMA OBJETO
----------------        ---------        -----------------

Processo de compila√ß√£o:
                                                                                 AN√ÅLISES
                            ‚îå ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ‚îê‚§∏
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  | ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê |
|PROGRAMA|  -\  [file1.cpp] | |lexycal |  \  | syntax |  \  |semantic|  \  |  code   | |
| FONTE  |  -/  [file2.cpp] | |analyzer|  /  |analyzer|  /  |analyzer|  /  |generator| |
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  | ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò |
 \                          |                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   |    |
  \                         |                                    v                v    |
   \     ‚åê ‚ñ°                |                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê |
    \   /                   ‚îî‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ|file1.obj|‚îÄ ‚îÄ |file2.obj|‚îÄ‚îò
     \ /                                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ° ------- ‚éò        ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä      ‚†Ä‚†Ä‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚áò           ‚áô
     / ‚áò‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚†Ä    ‚†Ä‚†Ä‚†Ä  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îê ‚†Ä   |              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚éó‚†Ä‚†Ä|BIBLIOTECAS|  ----------\‚†Ä|      | ‚†Ä   | -----------\ | L I N K E R |
     \  | EXTERNAS  |  ----------/ |      | ‚†Ä   | -----------/ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      \ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚†Ä   |      |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚†Ä     ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    | |
       ‚ñ°                        ‚†Ä  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚†Ä‚†Ä‚†Ä    ‚†Ä‚†Ä | |
                                      EXTERNAL                ‚†Ä‚†Ä     | |
                                     LIBRARIES                        \/
                                                             > EXECUTION RESULTS <
</pre>
##### AN√ÅLISES DE C√ìDIGO<br/>PR√â-PROCESSADOR
Na fase em que o c√≥digo fonte est√° sendo compilado, s√£o feitos 3 tipos de an√°lises:
1. *Lexical analyzer*
2. *Syntax analyzer*
3. *Semantic analyzer*

###### LEXICAL ANALYZER
 An√°lise lexica, tamb√©m conhecida como scaner ou leitura, √© a primeira fase do processo de compila√ß√£o, e sua fun√ß√£o √© realizar a leitura do programa fonte caractere por caractere e agrupar os caracteres em *"lexemas"* (produzir uma sequ√™ncia de s√≠mbolos l√©xicos conhecidos como *tokens*). Neste processo, a an√°lise l√©xica *particiona*, *classifica* e *elimina*.
<pre>
             PARTICIONA                            CLASSIFICA                                  ELIMINA
                 |                                      |                                         |
  identifica os elementos l√©xicos    -\        esses elementos s√£o:             -\        durante esse processo,
       (tokens) e os agrupa          -/      identificadores, palavras          -/     s√£o eliminados caracteres de
                                            reservadas, n√∫meros, strings,             espa√ßo em branco, coment√°rios...
                                            etc (ou seja, todo o conte√∫do                 
                                        relevante no c√≥digo para que funcione)            
</pre>

###### SYNTAX ANALYZER
 A sint√°xe de um programa √© a forma como ele define (atrav√©s de palavras reservadas, de indexa√ß√£o e de s√≠mbolos especiais) qual a estrutura relacionada para a codifica√ß√£o dentro daquela linguagem espec√≠fica (ou seja, define a corretude do programa).

>PADR√ÉO/GRAM√ÅTICA = Depende da linguagem usada.

###### SEMANTIC ANALYZER
 Sem√¢ntica √© o estudo do significado. Incide sobre a rela√ß√£o entre significantes, como: palavras, frases, sinais e s√≠mbolos (ou seja, √© a l√≥gica do programa).
<pre>
Exemplo de erro de sem√¢ntica:

     ‚¨ê erro de sem√¢ntica     \  /
if(x = 0):                     X
  print("o valor √© nulo")     / \ 


     ‚¨ê sem√¢ntica correta         /
if(x == 0):                   \ /
  print("o valor √© nulo")      V 
</pre>
 Por causa da l√≥gica errada (uso de operador de atribui√ß√£o no lugar do operador de compara√ß√£o) o programa n√£o fez aquilo que √© esperado, n√£o sendo poss√≠vel seguir com a compila√ß√£o, obrigando o desenvolvedor a debugar antes de seguir com o deploy do projeto.

#### INTERPRETA√á√ÉO
 Executa diretamente o c√≥digo fonte conforme a sua estrutura, ou seja, ele l√™, traduz e executa linha a linha do script ao inv√©s de analisar e gerar o programa objeto primeiro, como √© feito na compila√ß√£o.
<pre>
JAVASCRIPT, PYTHON:
__________________        ______
| PROGRAMA FONTE |   ->   | L√ä |   =   EXECUTA O PROGRAMA
------------------        ------
</pre>

##### INTERPRETADOR
 O processo de interpreta√ß√£o √© mais direto do que o processo de compila√ß√£o, pois n√£o h√° necessidade de gerar um c√≥digo intermedi√°rio antes da execu√ß√£o, a interpreta√ß√£o e a execu√ß√£o do programa acontecem em tempo real e independente do sistema operacional utilizado. Em vez disso, o c√≥digo-fonte √© interpretado e executado diretamente pelo interpretador. O c√≥digo da m√°quina gerado no momento da tradu√ß√£o n√£o √© armazenado para posterior execu√ß√£o mediante solicita√ß√£o. Portanto, o programa produzido com uma linguagem de programa√ß√£o traduzida por um int√©rprete sempre precisar√° do int√©rprete para poder ser executado. N√£o h√° independ√™ncia entre as fases de tradu√ß√£o e execu√ß√£o. Toda vez que o programa precisar ser executado, o tradutor ter√° que converter o c√≥digo fonte em c√≥digo de m√°quina (interpretar). Esta caracter√≠stica significa que, como regra geral, os idiomas que utilizam este tipo de tradutor oferecem um desempenho inferior. Por outro lado, eles oferecem um melhor ambiente de programa√ß√£o, depura√ß√£o e manuten√ß√£o do que o outro conjunto de tradutores: os compiladores.
 **Vantagens**
 - Depura√ß√£o r√°pida do c√≥digo, j√° que n√£o h√°  necessidade de recompilar ap√≥s uma mudan√ßa.
 - Manuten√ß√£o f√°cil e r√°pida do c√≥digo fonte.
 - O int√©rprete executa o programa desde a primeira linha e para a execu√ß√£o somente se encontrar um erro.
 - O int√©rprete n√£o gera c√≥digo de mem√≥ria intermedi√°rio, sendo mais eficientes em termos de mem√≥ria.
 **Desvantagens**
 - O usu√°rio tem acesso ao c√≥digo e pode copi√°-lo ou modific√°-lo.
 - A execu√ß√£o √© desacelerada, √© necess√°rio uma declara√ß√£o de cada vez como entrada, j√° que a interpreta√ß√£o linha por linha √© necess√°ria cada vez que o programa √© executado.
 - Um int√©rprete n√£o gera um c√≥digo intermedi√°rio conhecido como c√≥digo de m√°quina.
 - O erro √© relatado quando o primeiro erro √© encontrado. O resto do programa permanece sem controle at√© que o erro seja resolvido.
<pre>
           AN√ÅLISE L√âXICA E SINT√ÅTICA                                        EXECU√á√ÉO
                      |                                                         |
      o interpretador analisa o c√≥digo-fonte                      Ap√≥s a an√°lise l√©xica e sint√°tica,
   para identificar tokens e construir a estrutura      -\      o interpretador executa o c√≥digo linha
   de sintaxe. Isso pode ocorrer em conjunto, pois      -/   por linha ou instru√ß√£o por instru√ß√£o, conforme
  o interpretador pode processar cada linha de c√≥digo         ele √© interpretado. N√£o h√° gera√ß√£o de c√≥digo
          √† medida que √© encontrada.                         intermedi√°rio separado; o interpretador executa
                                                                      diretamente as instru√ß√µes.
</pre>

#### JIT
 Teoricamente, qualquer linguagem pode ser compilada ou interpretada e, por isso, h√° algumas linguagens que possuem ambas implementa√ß√µes mescladas, processo chamado de *Just in time* (JIT), que veio aperfei√ßoar a produ√ß√£o.<br/>
 Com o JIT n√≥s continuamos a interpretar os c√≥digos. Entretanto, n√≥s tamb√©m iremos compil√°-los, mas apenas a parte do c√≥digo que iremos usar no momento da execu√ß√£o. Isso representa um aumento muito grande de performance. Pois iremos usar o processo de compila√ß√£o, que j√° √© r√°pido, e ele ser√° executado em partes isoladas do c√≥digo, apenas na hora certa (‚Äújust in time‚Äù).<br/>
 Assim, temos √† disposi√ß√£o ‚Äúo melhor dos dois mundos‚Äù: a velocidade da compila√ß√£o junto da simplicidade de depura√ß√£o.<br/>
 Na linguagem Java, por exemplo, √© gerado um recurso de *bytecode*: c√≥digo pr√©-compilado que precisa ser interpretado pela *JVM* ou M√°quina Virtual Java para ser executado.

#### TRANSPILA√á√ÉO
 Linguagem de mais alto n√≠vel convertida para uma lingaguem mais baixa e ent√£o segue o fluxo, temos como exemplo, o TypeScript, que √© convertido para JavaScript e ent√£o lido pelo Node.JS para ser executado pelo computador.<br/>
 Transpila√ß√£o ou *Transpiling*, converte o c√≥digo fonte de uma linguagem de programa√ß√£o em um c√≥digo fonte equivalente da mesma ou de uma linguagem de programa√ß√£o diferente.<br/>
 Por exemplo o Babel, um transpilador de c√≥digo JavaScript. Babel converte o c√≥digo JavaScript da moderna vers√£o ECMAScript 2015+ em uma vers√£o antiga e compat√≠vel com os navegadores inferior.<br/>

Dada uma fun√ß√£o arrow ES2015 por exemplo:
```JS
  [2, 4, 6].map((n) => n * 2);
```
‚Ä¶Babel ir√° convert√™-lo em sua vers√£o ES5:
```JS
  [2, 4, 6].map(function(n){
    return n * 2;
  });
```

### PARADIGMAS DE PROGRAMA√á√ÉO
 Toda linguagem √© baseada em um paradigma. H√° tamb√©m linguagens baseadas em v√°rios, sendo consideradas nestes casos multiparadigmas. Quase todas as l√≠nguas modernas s√£o multiparadigm√°ticas. Combinam facilmente as capacidades das abordagens imperativa e declarativa.<br/>
 Os paradigmas s√£o modelagens de escrita de c√≥digo que podem ser aplicados a v√°rias linguagens, desde que estas permitam. √â poss√≠vel ainda aplicar mais de um paradigma a uma mesma solu√ß√£o em uma linguagem previamente escolhida.<br/>
 Um paradigma pode ser entendido como um tipo de estrutura√ß√£o ao qual a linguagem dever√° respeitar. A depender do objetivo proposto, a solu√ß√£o que a linguagem oferecer√° obedece a um tipo de paradigma. Portanto, o que vai definir o paradigma utilizado ser√° a tratativa dada ao problema.<br/>
 Diferentes tarefas de programa√ß√£o podem ser resolvidas de diferentes maneiras: talvez voc√™ possa precisar escrever uma fun√ß√£o, ou criar uma classe separada com m√©todos, e assim por diante. Todas essas variantes s√£o combinadas em diferentes abordagens de programa√ß√£o, tamb√©m chamadas de paradigmas.<br/>
 √â como se voc√™ tivesse que resolver um simples problema durante a execu√ß√£o de uma mudan√ßa dom√©stica. Imaginemos que voc√™ tenha que levar um piano do primeiro ao terceiro andar de sua resid√™ncia. O problema, j√° se sabe qual √©. Mas de qual forma (paradigma) resolver essa quest√£o?<br/>
 Pode-se optar por carreg√°-lo manualmente pelos andares acima. Esse seria um paradigma bastante trabalhoso, por exigir do esfor√ßo de v√°rias pessoas. No entanto, outro paradigma para esse problema poderia ser o de elev√°-lo por meio de um carrinho. Menos pessoas seriam necess√°rias e um menor esfor√ßo seria aplicado. Por fim, surge a ideia de usar um paradigma mais pr√°tico: elevar o piano pelo lado de fora da edifica√ß√£o utilizando um motor fixado no terceiro andar e acionado por controle remoto. Esfor√ßo quase zero e problema resolvido com mais intelig√™ncia.<br/>
 Na compara√ß√£o com a programa√ß√£o, esse seria um paradigma bem elegante (em termos de c√≥digo). Para escolher bem, √© preciso conhecer antes as alternativas.<br/>
 Ent√£o, por defini√ß√£o, um paradigma √© apresentado como: um exemplo que serve como modelo a ser seguido. Sendo assim, um paradigma √© um padr√£o ao qual linguagens de programa√ß√£o podem seguir. Eles indicam a forma como a linguagem deve operar para possilibitar a resolu√ß√£o de problemas.<br/>
 Cada paradigma foi criado para atender uma necessidade, cada um apresneta maiores vantagens sobre os outros dentro do desenvolvimento de determinado sistema, alguns prop√µe evolu√ß√µes a outros e todos t√™m aplicabilidade possibilitando que desenvolvedores(as) codifiquem programas que resolvam algum problema. Cada paradigma oferece t√©cnicas apropriadas para uma aplica√ß√£o espec√≠fica.<br/>
 √â uma forma de resolu√ß√£o de problemas com diretrizes e limita√ß√µes espec√≠ficas de cada paradigma utilizando linguagem de programa√ß√£o. S√£o eles:
<pre>
- IMPERATIVO    |   - L√ìGICO                   |   - COMPUTA√á√ÉO CONCORRENTE
- DECLARATIVO   |   - REATIVO                  |   - PROGRAMA√á√ÉO DE BANCO DE DADOS
- ESTRUTURADO   |   - MATEM√ÅTICO               |   - PROGRAMA√á√ÉO ORIENTADO A ASPECTOS
- PROCEDURAL    |   - COMPUTA√á√ÉO PARALELA      |   - PROGRAMA√á√ÉO ORIENTADA A EVENTOS
- FUNCIONAL     |   - COMPUTA√á√ÉO DISTRIBU√çDA   |   - PROGRAMA√á√ÉO ORIENTADA A OBJETOS
</pre>
 Escolhido(s) o(s) paradigma(s) de desenvolvimento adequado(s) ao projeto, isso permitir√° que sejam desenvolvidas aplica√ß√µes com grande produtividade. Haver√° unicidade na orienta√ß√£o de escrita do c√≥digo entre a equipe, tornando-o mais leg√≠vel e promovento facilidade na manuta√ß√£o e melhoria(s) ao longo da sua exist√™ncia. Al√©m disso, manter o mesmo paradigma determinar√° o objetivo dos desenvolvedores sobre a composi√ß√£o da estrutura e execu√ß√£o do sistema. Isso permite que as t√©cnicas adequadas sejam utilizadas no projeto em quest√£o. √â essencial manter essa metodologia durante todo o trabalho para que funcione adequadamente, seja de f√°cil leitura/entendimento e manunten√ß√£o.<br/>
 Para exemplificar os paradigmas, √© utilizado no decorrer do tema um exemplo bastante simples.<br/>
 A necessidade √© selecionar os n√∫meros pares em um intervalo de 1 a 10, e apresentar o resultado.
```Python
# IMPERATIVO (ESTRUTURADO)
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = []

for number in numbers:
  if(number % 2 == 0):
    even_numbers.append(number)

print(even_numbers)

# DECLARATIVO (FUNCIONAL)
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = list(filter(lambda number: number % 2 ==0, numbers))

print(even_numbers)
```
 No script acima o c√≥digo IMPERATIVO est√° ESTRUTURADO e o DECLARATIVO √© FUNCIONAL. A diferen√ßa entre eles n√£o est√° apenas na quantidade de c√≥digo escrito, mas nas inten√ß√µes expressadas em cada instru√ß√£o.<br/>
 Programar est√° associado a conhecer as poss√≠veis formas de enviar instru√ß√µes ao computador, logo compreender cada paradigma facilita o aprendizado de qualquer linguagem, a ponto de torn√°-las menos importantes.

#### IMPERATIVO
 O paradigma imperativo √© um dos mais antigos paradigmas da programa√ß√£o. √â um paradigma menos flex√≠vel, por conta da sequencialidade em que s√£o constru√≠das suas instru√ß√µes. Softwares que seguem este paradigma s√£o programados por meio de ordens condionais e blocos de comandos (para os quais as respostas das condi√ß√µes devem voltar uma vez que a instru√ß√£o tenha sido realizada). Est√° intimamente relacionado com a arquitetura da m√°quina. O foco principal desse paradigma √© em *"como"* atingir um objetivo.<br/>
 Um programa imperativo √© semelhante √†s ordens expressas pelo modo imperativo nas l√≠nguas naturais. O paradigma imperativo determina que as intru√ß√µes passadas ao computador devem especificar o passo-a-passo das a√ß√µes que ser√£o executadas. Tais a√ß√µes mudam o estado do programa atrav√©s do uso de vari√°veis que ficam armazenadas em mem√≥ria, at√© chegar a um resultado esperado. O foco do paradigma est√° em determinar o *"como"* deve ser feito.<br/>
 A programa√ß√£o imperativa permitiu uma codifica√ß√£o menos focada no c√≥digo de m√°quina, o que tamb√©m abriu as portas para a implementa√ß√£o de programas mais elaborados e menos dependentes do hardware.<br/>
 Nesse tipo de constru√ß√£o, as instru√ß√µes devem ser passadas ao computador na sequ√™ncia em que devem ser executadas. Ou seja, o desenvolvedor deve passar o roteiro dos procedimentos que a m√°quina ir√° executar. Nesse caso a solu√ß√£o do problema depende de alguma metodologia que descreva a experi√™ncia e a ordem a ser seguida pelo usu√°rio ao executar o programa.<br/>
 Esse tipo de programa√ß√£o √© recomendada em projetos nos quais n√£o se espera que haja mudan√ßas significativas ao longo do tempo (programa est√°tico), quando se tratar de uma opera√ß√£o complexa *- em que os diferentes estados da aplica√ß√£o necessitem de visualiza√ß√£o expl√≠cita*, ou quando n√£o existirem muitos elementos compartilhados.<br/>
 O paradigma consiste em v√°rias instru√ß√µes e, ap√≥s a execu√ß√£o de todas, o resultado √© armazenado ou exibido. Por exemplo, se voc√™ deseja exibir a frase `Ol√°, <nome do usu√°rio>!` na tela, como o programa deve fazer isso?<br/>
 Atrav√©s das seguintes etapas:
- solicitar o nome do usu√°rio
- guardar o nome do usu√°rio
- exibir o resultado esperado, isto √©, a frase: "Ol√°, &lt;nome do usu√°rio&gt;!"

##### DERIVA√á√ïES PI
 A programa√ß√£o imperativa √© dividida em 4 grandes categorias:
 1. *ESTRUTURADO*
 2. *PROCEDURAL*
 3. *COMPUTA√á√ÉO PARALELA*
 4. *PROGRAMA√á√ÉO ORIENTADA A OBJETOS*

#### DECLARATIVO
 O paradigma declarativo surgiu como uma abstra√ß√£o para simplificar a programa√ß√£o e permitir que os desenvolvedores se concentrem no problema, delegando a implementa√ß√£o de baixo n√≠vel para o sistema. Ele determina que as instru√ß√µes passadas ao computador devem especificar a sequ√™ncia l√≥gica e o resultado esperado, sem determinar o fluxo de controle. O foco est√° em determinar *"o qu√™"* precisa ser resolvido, o que √© um contraste a programa√ß√£o imperativa que determina *"o como"*.<br/>
 Historicamente o paradigma declarativo tem menos destaque do que o imperativo, por√©m ainda assim, possui algumas linguagens famosas baseadas no seu conceito, cita-se algumas como: SQL, HTML, JavaScript, Erlang e LISP.<br/>
 Continuando com os exemplos anteriores, mas transportando o cen√°rio para uma modelagem de dados relacional, vamos considerar uma tabela NUMBERS a qual cont√©m registros de 1 a 100.<br/>
 A necessidade √© obter a soma dos n√∫meros pares entre 1 e 10.<br/>
 No exemplo, um c√≥digo declarativo em SQL:

```SQL
  select sum(number) from numbers where mod(number, 2) = 0 and number <= 10
```

 Um c√≥digo reduzido, onde as instru√ß√µes est√£o focadas no resultado esperado e n√£o em como o computador chegar√° ao resultado.<br/>
 Muitas linguagens e frameworks d√£o suporte a uma *"mistura"* de c√≥digos relacionados ao paradigmas imperativo e declarativo, o que tem uma aplicabilidade e pode auxiliar desenvolvedores na resolu√ß√£o de problemas, mas que precisa ser utilizado de forma consciente. O uso inadequado pode gerar c√≥digos de dif√≠cil manuten√ß√£o e evolu√ß√£o, como em cen√°rios abaixo:
- C√≥digo declarativo com c√≥digo imperativo *"embutido"*, com uso de condicionais e outras estruturas de caracter√≠sticas imperativas.
- Composi√ß√£o de c√≥digo declarativo atrav√©s do uso de strings, que s√£o montadas a partir de c√≥digo imperativo.
- C√≥digos declarativos mistrurados a imperativos, cuja l√≥gica busca indicar ao computador o *"como fazer"*, o que contraria o prop√≥sito do paradigma.

 Em linguagens como SQL e HTML, s√£o comuns as situa√ß√µes apresentadas. Para estes casos, o indicado √© ter aten√ß√£o a como o paradigma declarativo trabalha. Normalmente uma linguagem declarativa possibilitar√° o recebimento de par√¢metros, os quais podem ser utilizados, mas sem que haja l√≥gica imperativa na resolu√ß√£o. Toda l√≥gica imperativa deve ser executada antes da execu√ß√£o do c√≥digo declarativo, e este deve apenas saber trabalhar com os par√¢metros recebidos.<br/>
 Atualmente o paradigma declarativo tem ganho destaque atrav√©s do uso de um outro paradigma que deriva dele, o funcional, o qual d√° mais poder para desenvolvedores, inclusive evitando a inadequada mistura de declarativo e imperativo.<br/>
 Como vimos, a programa√ß√£o declarativa √© um paradigma de programa√ß√£o no qual √© importante especificar o problema e o resultado esperado de sua solu√ß√£o. Ou seja, em contraste com o paradigma imperativo, onde √© necess√°rio responder √† pergunta **"COMO FAZER ISSO?"**, voc√™ precisa fazer as perguntas **"O QUE PRECISA SER FEITO?"** e **"QUAL SER√Å O RESULTADO DO TRABALHO?"**. Portanto, em vez de fornecer instru√ß√µes passo-a-passo, voc√™ diz ao sistema o que precisa no resultado e deixa que ele encontre uma solu√ß√£o.

##### DERIVA√á√ïES PD
 A programa√ß√£o declarativa √© dividida em 3 grandes tipos de paradigmas:
 1. *FUNCIONAL*
 2. *L√ìGICO*
 3. *REATIVO*
 4. *PROGRAMA√á√ÉO DE BANCO DE DADOS*

#### ESTRUTURADO
 Simplificadamente, este paradigma √© a constru√ß√£o de uma estrutura de blocos aninhados. O paradigma estruturado determina que as instru√ß√µes passadas ao computador podem ser formadas por 3 estruturas, sendo:
 1. *SEQU√äNCIA*: as instru√ß√µes s√£o codificadas na sequ√™ncia a serem executadas.
 2. *CONDI√á√ÉO*: um bloco de c√≥digo s√≥ √© executado se uma condi√ß√£o for verdadeira (`if`-`else`, `switch case`).
 3. *REPETI√á√ÉO*: um trecho de c√≥digo pode ser executado repetidas vezes (`for`, `while`, recursividade).

 Vamos ao exemplo da necessidade de somar n√∫meros pares de um determinado intervalo e apresentar o resultado. A programa√ß√£o estruturada permite maior dinamismo ao software, desta forma √© poss√≠vel coletar os dados e n√£o ficar preso a um conjunto est√°tico.

```Python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
summation_even_numbers = 0

for number in numbers:
  if (number % 2 == 0):
    summation_even_numbers += number

print(summation_even_numbers) # 30
```
 O c√≥digo acima ainda atua sobre um conjunto est√°tico de dados, o que fixa a execu√ß√£o para o intervalo de 1 a 10.

 J√° o c√≥digo abaixo amplia a capacidade do software e permite que agora ele seja aplicado a qualquer conjunto de n√∫meros informados na execu√ß√£o. O que mostra a import√¢ncia do paradigma estruturado para a evolu√ß√£o no desenvolvimento de software.
```Python
input = input("Digite os n√∫meros no formato: 1,2,3...\n> ")

numbers = [int(numeric) for numeric in input.split(",")]
summation_even_numbers = 0

for number in numbers:
  if (number % 2 == 0):
    summation_even_numbers += number

print("\n", summation_even_numbers)
```

 Destaca-se tamb√©m neste paradigma a capacidade de modulariza√ß√£o ou cria√ß√£o de subrotinas. Este paradigma se popularizou por propor uma forma de racioc√≠nio intuitivo, onde h√° legibilidade e compreens√£o de cada bloco de c√≥digo e tamb√©m por de certa forma, em √©poca, se opor ao uso de GOTO. A programa√ß√£o estruturada dominou a forma de programar at√© a d√©cada de 90, sendo desbancada com a populariza√ß√£o da POO, por√©m ela ainda √© bastante indicada para pessoas que est√£o aprendendo programa√ß√£o por ser uma forma simples de programar.<br/>
 Muitos softwares ainda possuem sua codifica√ß√£o seguindo o paradigma estruturado, o que n√£o caracteriza ser uma boa ou m√° codifica√ß√£o, por√©m normalmente n√£o condizem com as inten√ß√µes dos desenvolvedores. Isso porque muitas vezes estes creem estar usando paradigmas como PROCEDURAL ou POO, mas o c√≥digo continua seguindo o modelo ESTRUTURADO.<br/>
 Exemplos:
 - grandes blocos de c√≥digo estruturado fazendo muitas coisas distintas em um √∫nico m√©todo.
 - rotinas completas encapsuladas em classes mas que n√£o representam um objeto de fato.
 - classes/m√©todos com m√∫ltiplas responsabilidades, onde o que determina o c√≥digo a ser executado ainda s√£o as condicionais e repeti√ß√µes, muitas vezes utilizadas em excesso.

 O problema com rela√ß√£o aos pontos citados est√° em que muitos times de desenvolvimento n√£o conseguem distinguir a diferen√ßa entre o uso ESTRUTURADO, PROCEDURAL e POO, o que na pr√°tica leva a implementa√ß√£o de baixa qualidade com c√≥digos confusos e de alto custo de manuten√ß√£o. A programa√ß√£o estruturada √© √∫til e aplic√°vel, por√©m, seu uso sem considerar paradigmas complementares pode contribuir para c√≥digos de baixa legibilidade.

#### PROCEDURAL
 Este paradigma tamb√©m √© conhecido como o princ√≠pio de *"oculta√ß√£o dos procedimentos e dados"*, que consiste em dividir um programa em m√≥dulos (ou sub-programas, estes que podem ser compostos tamb√©m por um grupo de m√≥dulos), a fim de torn√°-lo mais leg√≠vel e administr√°vel. O paradigma procedural, determina que as instru√ß√µes a serem passadas ao computador podem ser agrupadas em procedimentos (equipar√°vel a m√©todos, fun√ß√µes e rotinas). Os procedimentos podem ser invocados durante a execu√ß√£o do software e visam a reutiliza√ß√£o do c√≥digo em pontos diferentes do mesmo, j√° que eles devem suportar a especifica√ß√£o de argumentos, vari√°veis locais, chamadas recursivas, dentre outros.<br/>
 Este paradigma √© baseado no conceito de chamadas de procedimento, as instru√ß√µes s√£o estruturadas em procedimentos tamb√©m conhecidos como sub-rotinas ou fun√ß√µes. Estes procedimentos s√£o uma lista de instru√ß√µes para dizer ao computador o que fazer passo-a-passo. Em outras palavras, o computador pega os dados de entrada e os processa sequencialmente em chamadas sucessivas e procedimentos separados (ideia de sequ√™ncia), lembrando-se de cada nova altera√ß√£o. O paradigma procedural √© excelente para programa√ß√£o de uso geral. Neste paradigma, o programador descreve um passo-a-passo detalhado do que deve ser cumprido pela m√°quina. V√°rios tipos de linguagem de programa√ß√£o suportam este tipo de paradigma, como Cobol, Fortran, Pascal, C, Java, C++, Kotlin, Python, PHP, JavaScript e ColdFusion.<br/>
 Em continuidade ao exemplo de c√≥digo estruturado, a necessidade agora √© fazer a soma dos n√∫meros pares e √≠mpares de um determinado intervalo, e apresentar o resultado. A programa√ß√£o estrutural permite o uso de procedimentos, desta forma fica mais f√°cil reaproveitar l√≥gica e c√≥digo.

```Python
def convert_to_numbers(string_numbers):
  numbers = [int(numeric) for numeric in string_numbers.split(",")]
  return numbers

def sum_numbers(numbers):
  summation_numbers = 0

  for number in numbers:
    summation_numbers += number

  return summation_numbers

def sum_even_numbers(numbers):
  even_numbers = []

  for number in numbers:
    if number % 2 == 0:
      even_numbers.append(number)

  return sum_numbers(even_numbers)

def sum_odd_numbers(numbers):
  odd_numbers = []

  for number in numbers:
    if number % 2 != 0:
      odd_numbers.append(number)

  return sum_numbers(odd_numbers)

input_str = input("\nDigite os n√∫meros no formato: 1,2,3...\n> ")
numbers_list = convert_to_numbers(input_str)

print("\nSoma n√∫meros pares: ", sum_even_numbers(numbers_list))
print("Soma n√∫meros √≠mpares: ", sum_odd_numbers(numbers_list))
```

 Com mais requisitos a serem atendidos, o c√≥digo come√ßa a ficar extenso, o que mostra a import√¢ncia do paradigma procedural para possibilitar o reaproveitamento e organiza√ß√£o do c√≥digo.<br/>
 Com o surgimento da POO, muitos times de desenvolvimento marginalizam de certa forma o uso puro de procedimentos, por√©m esse paradigma ainda √© bastante aplic√°vel mediante necessidades mais simples que n√£o requerem uma modelagem mais complexa no c√≥digo. Em solu√ß√µes corporativas, as quais normalmente possuem times de desenvolvimento grandes, o uso massivo de programa√ß√£o procedural geralmente leva a c√≥digos de dif√≠cil manuten√ß√£o e evolu√ß√£o, o que n√£o √© necessariamente exclusividade ou culpa deste paradigma, e sim o pouco cuidado ou conhecimento de desenvolvedores. O fato √© que para cen√°rios mais complexos, outros paradigmas oferecem mais recursos para contribuir com a organiza√ß√£o e qualidade do c√≥digo.

#### FUNCIONAL
 Suas instru√ß√µes baseadas em fun√ß√µes tem como objetivo declarar ao computador o resultado esperado, e n√£o o passo-a-passo para a constru√ß√£o deste resultado como nos demais paradigmas derivados da programa√ß√£o imperativa. Essa forma de compor o c√≥digo traz duas caracter√≠sticas que a tornam bastante diferente das demais, que s√£o a imutabilidade e por consequ√™ncia a n√£o mudan√ßa de estado do software.<br/>
 Uma fun√ß√£o √© um bloco de c√≥digo que realiza uma tarefa espec√≠fica e pode ser invocado v√°rias vezes.<br/>
 Este √© um paradigma de programa√ß√£o no qual o processo de computa√ß√£o √© interpretado como a computa√ß√£o dos valores das fun√ß√µes. A fun√ß√£o neste caso √© semelhante a uma fun√ß√£o matem√°tica, ou seja, uma fun√ß√£o na qual a entrada √© um array que n√£o √© alterado e a sa√≠da √© um novo array com novos dados. Isso torna uma fun√ß√£o matem√°tica diferente de uma fun√ß√£o na programa√ß√£o procedural, onde a fun√ß√£o √© uma sequ√™ncia de a√ß√µes que alteram os dados originais.<br/>
 Aqui est√° um exemplos simples: voc√™ pode ter uma fun√ß√£o que recebe uma lista de n√∫meros como entrada e retorna uma nova lista com os quadrados desses n√∫meros. Isso n√£o altera a lista original de n√∫meros.<br/>
 Vejamos outro exemplo, onde a necessidade √© obter a soma dos n√∫meros pares, √≠mpares e primos de um determinado intervalo e apresentar o resultado.

```Python
import sympy

def string_to_numbers(string_numbers):
  return list(map(int, eval(string_numbers)))

def filter_even_numbers(numbers):
  return filter(lambda number: number % 2 == 0, numbers)

def filter_odd_numbers(numbers):
  return filter(lambda number: number % 2 != 0, numbers)

def filter_prime_numbers(numbers):
  return filter(lambda number: sympy.isprime(number), numbers)

input = input("Digite os n√∫meros no formato: 1,2,3...\n> ")
numbers = string_to_numbers(input)
print("Soma n√∫meros pares: ", sum(filter_even_numbers(numbers)))
print("Soma n√∫meros √≠mpares: ", sum(filter_odd_numbers(numbers)))
print("Soma n√∫meros primos: ", sum(filter_prime_numbers(numbers)))
```

 A programa√ß√£o funcional permite um c√≥digo reduzido, focado em instru√ß√µes relacionadas ao resultado esperado. N√£o h√° modifica√ß√£o sobre qualquer vari√°vel, seguindo a linha da imutabilidade. Todas as instru√ß√µes s√£o atrav√©s da invoca√ß√£o de fun√ß√µes passando um valor de entrada e esperando um valor de sa√≠da, que pode ser o valor de entrada de outra fun√ß√£o.<br/>
 Para viabilizar essa estrutura, a programa√ß√£o funcional apoia-se sobre o uso de fun√ß√µes, as quais ao serem executadas mapeiam os valores de entrada para valores de sa√≠da, sem atualizar o estado do software, e quando usadas de forma combinada explicitam o poder do paradigma declarativo. As fun√ß√µes s√£o na programa√ß√£o funcional *"cidad√£s de primeira classe"*, assim como as Classes s√£o em POO.<br/>
 O uso de fun√ß√µes tem como base o uso do c√°lculo lambda, conceito desenvolvido ainda na d√©cada de 30, por Alonzo Church. Mas foi no final da d√©cada de 50 com o surgimento da linguagem LISP que o paradigma funcional foi aplicado pela primeira vez. Historicamente esse paradigma tem sido menos popular, mas atualmente ganhou for√ßa entre times de desenvolvimento, e o suporte j√° presente em linguagens como ML, Lisp, Miranda, Haskell, Scala, Erlang, Clojure, OCaml, F# e Elixir, tamb√©m se estende a linguagens como JavaScript, Python, Ruby, dentre outras.<br/>
 Assim como os demais paradigmas, qualquer problema pode ser resolvido com o paradigma funcional. O desafio para aqueles que desejam trabalhar com funcional puro, est√° em compreend√™-lo a ponto de utilizar os mecanismos adequados para lidar com a composi√ß√£o de l√≥gicas e estruturas de dados, de forma que n√£o contenham c√≥digos amarrados ao modelo imperativo e estruturado de programar.

##### LAMBDA (TERN√ÅRIO)
 Os seguintes termos s√£o usados de forma intercambi√°vel, dependendo da linguagem de programa√ß√£o usada: fun√ß√£o an√¥nima, fun√ß√µes an√¥nimas, fun√ß√µes lambda, nota√ß√µes lambda, express√£o lambda, express√µes lambda, abstra√ß√£o lambda, abstra√ß√µes lambda, forma lambda e literais de fun√ß√£o.<br/>
 Express√µes lambda diferem das fun√ß√µes comuns por serem declaradas de maneira diferente, sem definirmos nome para criarmos elas, utilizamos a palavra-chave lambda para defin√≠-las. Uma fun√ß√£o an√¥nima √© uma fun√ß√£o sem um nome associado, em vez de definir uma fun√ß√£o usando a palavra-chave `def` (em Python, por exemplo), voc√™ pode criar uma fun√ß√£o inline usando a sintaxe lambda: `lambda argumentos: express√£o`<br/>
 O c√°lculo lambda trata fun√ß√µes como cidad√£os de primeira classe. Isto significa que as fun√ß√µes podem ser utilizadas como argumentos e retornadas como valores de outras fun√ß√µes.<br/>
 Python e outras linguagens como Java, C# e at√© mesmo C++ tiveram as fun√ß√µes lambda adicionadas a sua sintaxe, j√° linguagens como LISP, ou linguagens da fam√≠lia ML (Meta Language: √© uma linguagem de programa√ß√£o funcional conhecida por usar o sistema de tipo polim√≥rfico Hindley-Milner, que atribui automaticamente os tipos de dados da maioria das express√µes sem exigir anota√ß√µes de tipos expl√≠citas (infer√™ncia de tipo) e garante a seguran√ßa de tipo.): Haskell, OCaml e F# usam lambdas como um conceito central.<br/>
 Express√µes Lambda em Python e em outras linguagens de programa√ß√£o possuem suas ra√≠zes no c√°lculo lambda, um modelo de computa√ß√£o criado por Alonzo Church. O c√°lculo lambda pode codificar qualquer c√°lculo, √© Turing completo, mas ao contr√°rio do conceito de m√°quina de Turing, √© puro e n√£o guarda nenhum estado.<br/>
 As linguagens de programa√ß√£o funcionais t√™m sua origem na l√≥gica matem√°tica e no c√°lculo lambda, enquanto as linguagens de programa√ß√£o imperativas adotam o modelo de computa√ß√£o baseado em estado inventado por Alan Turing. Os dois modelos de computa√ß√£o, c√°lculo lambda e m√°quinas de Turing, podem ser traduzidos um no outro. Essa equival√™ncia √© conhecida como hip√≥tese de Church-Turing. As linguagens funcionais herdam diretamente a filosofia do c√°lculo lambda, adotando uma abordagem declarativa de programa√ß√£o que enfatiza a abstra√ß√£o, a transforma√ß√£o de dados, a composi√ß√£o e a puzera (sem estado e sem efeitos colaterais).

- Express√µes lambda podem receber qualquer n√∫mero de argumentos, por√©m retornam apenas um valor na forma de express√£o, elas n√£o podem ter comandos ou multiplas express√µes.
- Uma fun√ß√£o an√¥nima n√£o pode ser chamada diretamente pela fun√ß√£o `print()`, pois ela requer uma express√£o.

 Uma fun√ß√£o lambda (ou an√¥nima) √© uma pequena fun√ß√£o que voc√™ pode definir inline e usar onde for necess√°rio sem atribuir um nome a ela. √â como uma receita de bolo que voc√™ pode usar uma √∫nica vez, sem precisar guard√°-la na sua cole√ß√£o de receitas.

 Exemplo pr√°tico: voltando ao exemplo dos quadrados, queremos uma fun√ß√£o para dobrar um n√∫mero. Normalmente, voc√™ escreveria algo assim em Python:

```Python
def dobrar(numero):
    return numero * 2

resultado = dobrar(5)
print(resultado)
```

 Mas com uma fun√ß√£o lambda, voc√™ pode fazer o mesmo em uma linha, sem atribuir um nome √† fun√ß√£o e sem alterar o estado da vari√°vel que contem o valor a ser manipulado:

```Python
  resultado = (lambda numero: numero * 2)(5)
  print(resultado)
```

 A fun√ß√£o lambda `(lambda numero: numero * 2)` toma um argumento chamado `numero` e retorna `numero * 2`, n√£o tendo altera√ß√£o no estado/valor da vari√°vel `numero`. Ent√£o, (5) √© o argumento passado para essa fun√ß√£o lambda, resultando em 5 * 2, que √© 10.

 Podemos observar o qu√£o simples √© a estrutura da fun√ß√£o lambda:
<pre>
 ------------------------------------------------------
| lambda argumento1, argumento2, argumento3: express√£o |
 ------------------------------------------------------
</pre>

Vejamos outro exemplo, vamos multiplicar o argumento por 3:

```Python
  triplo = lambda x: x * 3
  print(type(triplo)) # <class 'function'>
  print(triplo(3)) # 9
```

 Agora vamos elevar o n√∫mero ao quadrado:

```Python
  quadrado = lambda x: x * x
  print(quadrado(5)) # 25
```

 As express√µes lambda tamb√©m nos permitem trabalharmos com strings, por exemplo:

```Python
#                 ‚Ü±func  ‚Ü±arg1 ‚Ü±agr2       ‚Ü±express√£o
  nome_completo = lambda nome, sobrenome: f'Nome: {nome.title()}\nSobrenome: {sobrenome.title()}'
  print(nome_completo('Satoshi', 'Nakamoto'))
# Nome: Satoshi
# Sobrenome: Nakamoto
```

 Podemos tamb√©m usar condicionais com fun√ß√µes lambda:

```Python
#            argumento ‚¨é    ‚¨ê express√£o condicional ----------‚¨é
  comeca_com_D = lambda x: True if x.startswith('D') else False
  print(comeca_com_D('D√©borah')) # True
  print(comeca_com_D('Raphael')) # False
```

 Se quisermos verificar se um n√∫mero √© impar:

```Python
  impar = lambda x: True if x % 2 == 1 else False
  print(impar(1)) # True
  print(impar(2)) # False
```

 At√© mesmo compor fun√ß√µes mais complexas, como imprimir a palavra que vem antes da palavra passada via argumento:

```Python
palavra_anterior = lambda s, w: s.split()[s.split().index(w)-1] if w in s else None
sentenca = 'Rato Roeu Roupa Rei Roma'
print(palavra_anterior(sentenca, 'Roma')) # Rei
```

 Fun√ß√µes lambda normalmente s√£o usadas quando precisamos de uma fun√ß√£o por um curto per√≠odo de tempo, podemos tamb√©m us√°-las como argumentos para fun√ß√µes high-order (fun√ß√µes que recebem outras fun√ß√µes como argumento).<br/>
 Fun√ß√µes lambda tamb√©m podem ser usadas com outras fun√ß√µes pr√©-constru√≠das, como alguns exemplos de Python: `filter()`, `map()` e etc.<br/>
 Na computa√ß√£o Fun√ß√µes de Alta Ordem tamb√©m s√£o conhecidas como Fun√ß√µes de Primeira Classe. S√£o fun√ß√µes que suportam a passagem de outras fun√ß√µes como argumentos retornando como valor para outras fun√ß√µes. Ou seja, s√£o fun√ß√µes que operam em outras fun√ß√µes, seja levando-os como argumentos ou devolvendo-os. A ideia de fun√ß√µes como entidades de primeira classe √© que as fun√ß√µes tamb√©m sejam tratadas como valores e usadas como dados.<br/>
 Fun√ß√µes como entidades de primeira classe podem:
- Ser consultadas a partir de constantes de vari√°veis
- Passadas como par√¢metros para outras fun√ß√µes
- Ser retornadas como resultados de outras fun√ß√µes

 A ideia de tratar fun√ß√µes como valores e passar fun√ß√µes como dados nos permite combinar fun√ß√µes com outras fun√ß√µes para criar novas fun√ß√µes com novos comportamentos. Essas fun√ß√µes possuem l√≥gica semelhante, mas a diferen√ßa s√£o as fun√ß√µes dos operadores. Se pudermos tratar fun√ß√µes como valores e pass√°-los como argumentos, podemos construir uma fun√ß√£o que receba a fun√ß√£o do operador e us√°-la dentro da nossa fun√ß√£o.

##### ARROW (TERN√ÅRIO)
 O JavaScript por exemplo, tem a habilidade HOF que d√° suporte para uso da programa√ß√£o funcional. De certa forma podemos dizer que o Self-Invoking Function √© uma Higher-Order Function; Higher-Order Functions s√£o fun√ß√µes que recebem ou retornam outras: uma HOF √© uma fun√ß√£o que pode receber outras fun√ß√µes como argumentos e/ou retornar uma fun√ß√£o como resultado. Em resumo, as HOFs tratam as fun√ß√µes como valores de primeira classe.<br/>
 Arrow functions no JavaScript s√£o uma forma concisa de escrever fun√ß√µes, introduzidas no ES6 (ECMAScript). Elas s√£o uma alternativa mais simples e mais curta √†s fun√ß√µes tradicionais, al√©m de comportarem-se de maneira diferente em rela√ß√£o ao `this`.<br/>
 A sintaxe b√°sica de uma arrow function √© a seguinte:

```JS
const nomeDaFuncao = (param1, param2) => {
    // corpo da fun√ß√£o
}
```

 N√£o √© comum vermos HOF em linguagens tradicionais. O programador imperativo certamente usar√° um loop para iterar um array, por√©m, o funcional adotar√° uma abordagem completamente diferente. Podemos trabalhar o array com uma HOF, aplicando-a em cada item para criar um novo array. Essa √© a ideia central do paradigma funcional. Uma HOF permite-nos passar sua l√≥gica a outras fun√ß√µes, bem como objetos.<br/>
 Exemplos comuns de HOFs em JavaScript incluem `map`, `filter`, `reduce`, `forEach`, `sort`, entre outros m√©todos de arrays que recebem fun√ß√µes como argumentos para manipular os elementos do array.<br/>
 Aqui temos um exemplo simples usando `map`, uma HOF, que recebe uma fun√ß√£o como argumento para dobrar todos os elementos de um array:

```JS
const numeros = [1, 2, 3, 4, 5];

const numerosDobrados = numeros.map(function(numero) {
  return numero * 2;
});

console.log(numerosDobrados); // Sa√≠da: [2, 4, 6, 8, 10]
```

 Neste exemplo, a fun√ß√£o passada para `map` √© uma fun√ß√£o an√¥nima que dobra cada elemento do array `numeros`. Essa fun√ß√£o an√¥nima √© um exemplo de uma HOF.<br/>
 Fun√ß√µes em JavaScript s√£o tratadas com *"cidad√£s de primeira classe"*, tal comportamento pode ser encontrado no Haskell, Scheme ou em linguagens funcionais cl√°ssicas. Esse termo pode soar bizarro - cidad√£s de primeira classe -, mas isso simplesmente quer dizer que fun√ß√µes s√£o tratadas da mesma maneira que tipos primitivos: n√∫meros e objetos. Se n√∫meros e objetos tem *"passe livre"*, fun√ß√µes tamb√©m t√™m. Valores de primeira classe (ou first-class values) referem-se √† capacidade de uma linguagem de programa√ß√£o tratar entidades (como fun√ß√µes) como qualquer outro tipo de valor. Em resumo, isso significa que essas entidades podem ser atribu√≠das a vari√°veis, passadas como argumentos para outras fun√ß√µes, retornadas como resultados de fun√ß√µes e armazenadas em estruturas de dados. Em uma linguagem com suporte a valores de primeira classe, as fun√ß√µes s√£o tratadas da mesma maneira que strings, n√∫meros ou qualquer outro tipo de dado. Isso traz flexibilidade ao c√≥digo, permitindo que as fun√ß√µes sejam manipuladas dinamicamente, o que √© fundamental em paradigmas de programa√ß√£o como programa√ß√£o funcional.<br/>
 √â poss√≠vel atribuir essas fun√ß√µes a vari√°veis `var` ou `let` ou ainda a constantes `const`.

```JS
var soma = (x, y) => x + y;
let subtracao = (x, y) => x - y;
const calcular = (fn, x, y) => fn(x, y);

console.log(calcular(soma, 2, 1)); // 3
console.log(calcular(subtracao, 2, 1)); // 1
```

 Se a fun√ß√£o tiver apenas uma express√£o, voc√™ pode omitir as chaves `{}` e o `return` (se a express√£o for retornada diretamente).

```JS
const soma = (a, b) => a + b;
```

**Fun√ß√£o tradicional vs. Arrow Function**

**Fun√ß√£o Tradicional:**
```JS
function saudacao(nome) {
    return 'Ol√°, ' + nome;
}
```

**Arrow Function:**
```JS
const saudacao = (nome) => 'Ol√°, ' + nome;
```

**Fun√ß√µes sem par√¢metros**<br/>
 Se a fun√ß√£o n√£o tiver par√¢metros, voc√™ pode usar um par√™ntese vazio:
```JS
const dizerOla = () => 'Ol√°!';
```

**Fun√ß√£o com apenas um par√¢metro**<br/>
 Se a fun√ß√£o tiver apenas um par√¢metro, voc√™ pode omitir os par√™nteses:
```JS
const dobro = x => x * 2;
```

**Fun√ß√µes com m√∫ltiplos par√¢metros**<br/>
 Com m√∫ltiplos par√¢metros, os par√™nteses s√£o necess√°rios:
```JS
const soma = (a, b) => a + b;
```

 Usando arrow functions com `this`: Uma das caracter√≠sticas importantes das arrow functions √© que elas n√£o t√™m o pr√≥prio `this`. Isso significa que o valor de `this` dentro de uma arrow function √© herdado do contexto onde a fun√ß√£o foi criada, ao inv√©s de ser determinado pela maneira como a fun√ß√£o √© chamada. Com uma fun√ß√£o tradicional, `this` se refere ao objeto que chamou a fun√ß√£o. J√° com arrow functions, `this` mant√©m o valor de onde a fun√ß√£o foi criada.

*Fun√ß√£o tradicional:*
```JS
function Contador() {
    this.valor = 0;
    setInterval(function() {
        this.valor++;  // 'this' se refere ao contexto global ou ao objeto window
        console.log(this.valor);
    }, 1000);
}
```

*Arrow Function:*
```JS
function Contador() {
    this.valor = 0;
    setInterval(() => {
        this.valor++;  // 'this' refere-se ao contexto de Contador
        console.log(this.valor);
    }, 1000);
}
```

 Podemos atribuir uma fun√ß√£o a uma vari√°vel, pass√°-la como argumento para outra fun√ß√£o e retorn√°-la como resultado de uma fun√ß√£o, como demonstrado neste c√≥digo:
```JS
// Atribuindo uma fun√ß√£o a uma vari√°vel
const saudar = saudacaoFactory('Ol√°');

// Fun√ß√£o que retorna outra fun√ß√£o
function saudacaoFactory(saudacao) {
  return function(nome) {
    console.log(`${saudacao}, ${nome}!`);
  };
}

// Chamando a fun√ß√£o armazenada na vari√°vel
saudar('Jo√£o'); // Sa√≠da: Ol√°, Jo√£o!

// ----------------------------------------------------

// Passando uma fun√ß√£o como argumento para outra fun√ß√£o
function executaOperacao(operacao, a, b) {
  return operacao(a, b);
}

function soma(a, b) {
  return a + b;
}

console.log(executaOperacao(soma, 2, 3)); // Sa√≠da: 5
 ```
 Neste exemplo, as fun√ß√µes s√£o tratadas como valores de primeira classe, Isso demonstra a flexibilidade proporcionada por valores de primeira classe. As arrow functions oferecem uma maneira mais compacta e expressiva de escrever fun√ß√µes em JavaScript, al√©m de modificar o comportamento do`this`, o que pode ser √∫til para evitar problemas em certos contextos, como dentro de callbacks e fun√ß√µes ass√≠ncronas.

#### L√ìGICO
 O paradigma l√≥gico √© um tanto distinto dos demais paradigmas e deriva do declarativo. Fundamentalmente, utiliza formas de l√≥gica simb√≥lica como padr√µes de entrada e sa√≠da. A partir da√≠ realiza infer√™ncias para produzir os resultados. A programa√ß√£o l√≥gica √© um paradigma de programa√ß√£o fortemente baseado na l√≥gica formal. Qualquer paradigma escrito em uma linguagem de programa√ß√£o l√≥gica √© um conjunto de senten√ßas em uma forma l√≥gica que expressa fatos e regras sobre uma determinada √°rea do problema.

##### PRINC√çPIOS
 Portanto, as declara√ß√µes b√°sicas da programa√ß√£o l√≥gica s√£o as seguintes:
 - *FATOS*: s√£o afirma√ß√µes fundamentais sobre o dom√≠nio do problema, como "Alan Turing √© um homem".
 - *REGRAS*: permitem fazer infer√™ncias sobre os fatos do dom√≠nio ("Todos os homens s√£o mortais.").
 - *CONSULTAS*: s√£o quest√µes sobre esse dom√≠nio ("Alan Turing √© mortal?").

 Em geral, a tarefa aqui √© encontrar a resposta para a consulta com base em fatos e regras. As principais fam√≠lias de linguagens de programa√ß√£o l√≥gica incluem QLISP, Mercury, Prolog, Answer Set Programming (ASP) e Datalog. S√£o utilizadas na solu√ß√£o de problemas que envolvem intelig√™ncia artificial, cria√ß√£o de programas especializados e comprova√ß√£o de teoremas.<br/>
 Para exemplificar bem seu uso, podemos imaginar a tentativa de prova de um dado teorema, na qual s√£o explicitadas algumas premissas e, sendo elas verdadeiras, a conclus√£o de tal teorema torna-se verdade tamb√©m.<br/>
 A estrutura consiste em descrever as rela√ß√µes e regras que governam um problema e deixa o computador descobrir a solu√ß√£o usando l√≥gica.

#### REATIVO
 O paradigma de programa√ß√£o reativo √© uma abordagem na qual os sistemas s√£o constru√≠dos em torno da ideia de fluxos de dados que podem ser observados e reagidos. Em outras palavras, em vez de lidar apenas com eventos isolados, o foco est√° na cria√ß√£o de programas que respondem a mudan√ßas de maneira cont√≠nua e autom√°tica.<br/>
 A programa√ß√£o reativa √© derivada principalmente do paradigma declarativo. No paradigma declarativo, os programas s√£o estruturados em torno da declara√ß√£o do que deve ser feito, em vez de especificar exatamente como alcan√ßar o resultado desejado. Isso est√° alinhado com os princ√≠pios da programa√ß√£o reativa, onde os desenvolvedores declaram como os componentes do sistema devem reagir a eventos e mudan√ßas de estado, em vez de controlar manualmente o fluxo de execu√ß√£o.<br/>
 Na programa√ß√£o reativa, os fluxos de dados s√£o declarados e os desenvolvedores definem como reagir a esses fluxos, permitindo uma abordagem mais declarativa para lidar com a comunica√ß√£o ass√≠ncrona e eventos em tempo real. Portanto, embora a programa√ß√£o reativa possa incorporar elementos de outros paradigmas, como o paradigma funcional ou o paradigma orientado a objetos, sua base principal est√° enraizada no paradigma declarativo.<br/>
 A programa√ß√£o reativa pode ser implementada em v√°rias linguagens de programa√ß√£o. Algumas linguagens t√™m suporte nativo para programa√ß√£o reativa, enquanto outras podem usar bibliotecas de terceiros para adicionar recursos reativos. Algumas das linguagens comumente usadas que suportam programa√ß√£o reativa s√£o JavaScript, Java, Kotlin, Swift, C#, Python, Elm (linguagem de programa√ß√£o funcional pura projetada para criar interfaces de usu√°rio reativas na web. Ele segue o modelo de arquitetura de atualiza√ß√£o de modelo de vis√£o (Model-View-Update) e enfatiza a imutabilidade e a aus√™ncia de efeitos colaterais), Elixir, Scala e ReactiveX (API dispon√≠vel em v√°rias linguagens de programa√ß√£o, incluindo JavaScript, Java, Kotlin, Swift, C#, Python e muitas outras. Permite programa√ß√£o reativa ass√≠ncrona usando observ√°veis (observables) e operadores (operators) para manipular fluxos de dados).

##### PRINCIPAIS ASPECTOS
 - *Fluxos de Dados (Streams)*: S√£o sequ√™ncias de eventos que ocorrem ao longo do tempo e podem ser observadas por partes do programa.
 - *Reatividade*: Refere-se √† capacidade do programa de responder dinamicamente a mudan√ßas nos fluxos de dados, atualizando automaticamente sua sa√≠da conforme novos eventos ocorrem.
 - *Assincronicidade*: Permite que o programa execute v√°rias tarefas simultaneamente, sem precisar esperar que uma opera√ß√£o seja conclu√≠da antes de prosseguir.
 - *Composi√ß√£o Declarativa*: Os programas reativos s√£o frequentemente expressos de forma declarativa, o que significa que os desenvolvedores definem o que desejam alcan√ßar, em vez de especificar explicitamente como faz√™-lo.

 Imagine um aplicativo de previs√£o do tempo que exibe automaticamente atualiza√ß√µes quando os dados s√£o alterados. Neste aplicativo, os dados do clima s√£o transmitidos continuamente como fluxos de dados. Os desenvolvedores podem observar esses fluxos e reagir a eles, atualizando a interface do usu√°rio sempre que novas informa√ß√µes estiverem dispon√≠veis.<br/>
 Neste exemplo, vamos simular um sistema simples de monitoramento de temperatura, onde os dados de temperatura s√£o gerados aleatoriamente e atualizados continuamente. Vamos observar esses dados e imprimir as atualiza√ß√µes conforme elas ocorrem:
```Python
from rx import from_iterable
import random
import time

# Fun√ß√£o para gerar dados de temperatura aleat√≥rios
def generate_temperature():
    while True:
        yield random.randint(0, 100)
        time.sleep(1)  # Aguarda 1 segundo antes de gerar o pr√≥ximo dado

# Cria um fluxo de dados de temperatura
temperature_stream = from_iterable(generate_temperature())

# Observa o fluxo de dados e imprime as atualiza√ß√µes de temperatura
subscription = temperature_stream.subscribe(lambda temperature: print("Nova temperatura:", temperature))

# Mant√©m o programa em execu√ß√£o para observar as atualiza√ß√µes de temperatura
input("Pressione Enter para encerrar o programa...\n")
```
 Neste exemplo, estamos usando a fun√ß√£o `generate_temperature()` para gerar dados de temperatura aleat√≥rios continuamente. Em seguida, criamos um fluxo de dados reativo a partir desses dados usando `from_iterable()`. Finalmente, observamos esse fluxo de dados e imprimimos as atualiza√ß√µes de temperatura √† medida que elas ocorrem. Execute este c√≥digo e voc√™ ver√° as atualiza√ß√µes de temperatura sendo impressas no console a cada segundo. Isso demonstra a capacidade de lidar com fluxos de dados em tempo real de forma reativa. Ao entender esses conceitos fundamentais, os desenvolvedores podem criar aplicativos que sejam mais responsivos, din√¢micos e capazes de lidar eficientemente com fluxos de dados em tempo real.

#### MATEM√ÅTICO
 Derivado do paradigma de programa√ß√£o declarativa, o paradigma de programa√ß√£o matem√°tico √© uma abordagem na qual os problemas s√£o formulados e resolvidos usando conceitos e t√©cnicas da matem√°tica. Em outras palavras, √© como resolver problemas usando equa√ß√µes e f√≥rmulas matem√°ticas.<br/>
 Vamos considerar um problema de planejamento de produ√ß√£o em uma f√°brica, onde queremos maximizar os lucros sujeitos a certas restri√ß√µes, como limita√ß√µes de recursos e demanda do mercado. Em vez de tentar resolver esse problema manualmente, podemos usar programa√ß√£o matem√°tica.<br/>
 Digamos que temos tr√™s produtos A, B e C, e queremos decidir quantos de cada produto produzir para maximizar os lucros. Podemos formular este problema como um problema de programa√ß√£o linear, com uma fun√ß√£o objetivo para maximizar os lucros e um conjunto de restri√ß√µes que representam as limita√ß√µes de recursos e demanda.<br/>
 Uma poss√≠vel formula√ß√£o matem√°tica poderia ser:
<pre>
 _____________________________________________________________
| Maximizar:                                                  |
| Lucro Total = 10A + 15B + 20C                               |
|                                                             |
| Sujeito a:                                                  |
| 1A + 2B + 3C <= 100 (Restri√ß√£o de horas de m√£o-de-obra)     |
| 3A + 2B + 1C <= 90 (Restri√ß√£o de mat√©ria-prima)             |
| A, B, C >= 0 (Quantidade de produtos n√£o pode ser negativa) |
 -------------------------------------------------------------
</pre>
 Aqui, A, B e C representam as quantidades dos produtos A, B e C a serem produzidos, respectivamente. O objetivo √© maximizar o lucro total, sujeito √†s restri√ß√µes de recursos dispon√≠veis.

 Em Python, voc√™ pode resolver este problema de programa√ß√£o matem√°tica utilizando bibliotecas espec√≠ficas para otimiza√ß√£o, como a biblioteca PuLP:
```Python
from pulp import LpMaximize, LpProblem, LpVariable

# Cria o problema de maximiza√ß√£o
problem = LpProblem("Maximiza√ß√£o de Lucro", LpMaximize)

# Define as vari√°veis de decis√£o
A = LpVariable("A", lowBound=0)  # Quantidade de produto A
B = LpVariable("B", lowBound=0)  # Quantidade de produto B
C = LpVariable("C", lowBound=0)  # Quantidade de produto C

# Define a fun√ß√£o objetivo
problem += 10*A + 15*B + 20*C, "Lucro_Total"

# Adiciona as restri√ß√µes
problem += 1*A + 2*B + 3*C <= 100, "Restri√ß√£o_M√£o_de_obra"
problem += 3*A + 2*B + 1*C <= 90, "Restri√ß√£o_Mat√©ria_prima"

# Resolve o problema
problem.solve()

# Imprime o status da solu√ß√£o
print("Status:", problem.status)

# Imprime o valor √≥timo das vari√°veis de decis√£o
print("Quantidade de A:", A.varValue)
print("Quantidade de B:", B.varValue)
print("Quantidade de C:", C.varValue)

# Imprime o valor √≥timo da fun√ß√£o objetivo (lucro total)
print("Lucro Total:", problem.objective.value())
```
 Este √© apenas um exemplo simples, mas mostra como a programa√ß√£o matem√°tica pode ser usada para resolver problemas do mundo real de forma eficiente e sistem√°tica, usando conceitos e t√©cnicas da matem√°tica.

##### CONCEITOS E T√âCNICAS
 O paradigma de programa√ß√£o matem√°tico √© uma abordagem na qual os problemas s√£o formulados e resolvidos usando conceitos e t√©cnicas da matem√°tica. Ele se baseia em modelos matem√°ticos precisos para representar problemas do mundo real e usar algoritmos de otimiza√ß√£o para encontrar solu√ß√µes eficientes para esses problemas.

- **Rela√ß√£o com l√≥gica matem√°tica:**<br/>
 A l√≥gica matem√°tica fornece as bases te√≥ricas para a constru√ß√£o de modelos formais e a an√°lise rigorosa de argumentos e proposi√ß√µes. Ela ajuda a estabelecer a validade de teoremas e m√©todos de prova que s√£o fundamentais para a formula√ß√£o e resolu√ß√£o de problemas em programa√ß√£o matem√°tica, estuda os princ√≠pios do racioc√≠nio v√°lido e da infer√™ncia. Ela se preocupa com a an√°lise formal das proposi√ß√µes e argumentos, usando ferramentas matem√°ticas para investigar suas propriedades e estruturas.

- **Principais conceitos da l√≥gica matem√°tica:**
 1. *L√≥gica proposicional*: Trata da an√°lise de proposi√ß√µes simples e da constru√ß√£o de argumentos usando conectivos l√≥gicos, como *"e"*, *"ou"* e *"n√£o"*. Na programa√ß√£o matem√°tica, proposi√ß√µes l√≥gicas podem ser usadas para representar restri√ß√µes e condi√ß√µes nos modelos matem√°ticos.
 2. *L√≥gica de predicados*: Estende a l√≥gica proposicional para lidar com proposi√ß√µes que cont√™m vari√°veis e quantificadores, permitindo a representa√ß√£o de conceitos mais complexos. Na programa√ß√£o matem√°tica, a l√≥gica de predicados pode ser usada para expressar rela√ß√µes  entre vari√°veis e restri√ß√µes em modelos matem√°ticos.
 3. *Teoria dos modelos*: Investiga√ß√£o de modelos matem√°ticos que representam sistemas formais e a validade de certas proposi√ß√µes e  argumentos dentro desses modelos. Na programa√ß√£o matem√°tica, a teoria dos modelos pode ser usada para validar solu√ß√µes obtidas  por meio de algoritmos de otimiza√ß√£o.
 4. *Teoria dos conjuntos*: Estuda conjuntos e suas propriedades, bem como as opera√ß√µes que podem ser realizadas neles, como uni√£o, interse√ß√£o e complemento.
 5. *Teoria da computabilidade*: Estuda os limites e as capacidades dos sistemas de computa√ß√£o, investigando quest√µes de decidibilidade e complexidade computacional.
 6. *Teoria da prova*: Explora m√©todos formais para demonstrar a validade de teoremas matem√°ticos, incluindo o uso de *axiomas*, *regras de infer√™ncia* e *t√©cnicas de dedu√ß√£o*.

- **Rela√ß√£o com l√≥gica combinat√≥ria:**<br/>
 A l√≥gica combinat√≥ria est√° preocupada com a an√°lise e a enumera√ß√£o de diferentes possibilidades de arranjos, combina√ß√µes e permuta√ß√µes de elementos em conjuntos finitos. Ela fornece t√©cnicas para contar e enumerar possibilidades, o que √© √∫til na an√°lise de problemas de programa√ß√£o matem√°tica que envolvem escolhas discretas e estruturas combinat√≥rias. Ela lida com a an√°lise e o estudo de arranjos, combina√ß√µes e permuta√ß√µes de elementos em conjuntos finitos. Ela est√° preocupada principalmente com a contagem e a enumera√ß√£o de diferentes possibilidades de agrupamentos ou arranjos de elementos, levando em considera√ß√£o diversas restri√ß√µes e condi√ß√µes.<br/>
 A l√≥gica combinat√≥ria √© amplamente aplicada em v√°rias √°reas, incluindo matem√°tica discreta, teoria dos grafos, ci√™ncia da computa√ß√£o, criptografia, teoria da probabilidade e muito mais. Alguns t√≥picos comuns abordados na l√≥gica combinat√≥ria incluem os conceitos abaixo.

- **Principais conceitos da l√≥gica combinat√≥ria:**
 1. *Permuta√ß√µes*: Arranjos ordenados de elementos, onde a ordem dos elementos √© importante. Na programa√ß√£o matem√°tica, permuta√ß√µes podem  ser usadas para representar arranjos de vari√°veis ou decis√µes em um modelo.
 2. *Combina√ß√µes*: Arranjos n√£o ordenados de elementos, onde apenas os elementos selecionados importam, n√£o a ordem em que s√£o selecionados. Na programa√ß√£o matem√°tica, combina√ß√µes podem ser usadas para representar escolhas de subconjuntos de vari√°veis ou recursos.
 3. *Princ√≠pio da multiplica√ß√£o/adi√ß√£o*: Princ√≠pios fundamentais usados para contar o n√∫mero de maneiras de realizar uma s√©rie de eventos. Na programa√ß√£o matem√°tica, esses princ√≠pios podem ser aplicados para calcular o n√∫mero total de solu√ß√µes poss√≠veis para um problema.
 4. *Princ√≠pio da inclus√£o/exclus√£o*: Um m√©todo para contar elementos que est√£o em diferentes conjuntos ou categorias, levando em considera√ß√£o a sobreposi√ß√£o entre eles.
 5. *Teorema do bin√¥mio*: Uma f√≥rmula para expandir express√µes de bin√¥mios e calcular coeficientes binomiais.
 6. *Teoria dos grafos*: Uma √°rea da matem√°tica que lida com a representa√ß√£o e an√°lise de rela√ß√µes entre objetos usando diagramas conhecidos como grafos.
 7. *Problemas de contagem*: Uma variedade de problemas que envolvem contar o n√∫mero de solu√ß√µes poss√≠veis para uma determinada situa√ß√£o, muitas vezes usando t√©cnicas de permuta√ß√£o, combina√ß√£o e princ√≠pios de contagem. Esses problemas s√£o comuns na formula√ß√£o e resolu√ß√£o de problemas de programa√ß√£o matem√°tica.
 
 Em resumo, o paradigma de programa√ß√£o matem√°tica usa conceitos e t√©cnicas da l√≥gica matem√°tica e da l√≥gica combinat√≥ria para formular e resolver problemas usando modelos matem√°ticos precisos e algoritmos de otimiza√ß√£o eficientes.

 **1. Modelagem Matem√°tica:**<br/>
 Modelagem matem√°tica √© o processo de traduzir um problema do mundo real em termos matem√°ticos, representando suas caracter√≠sticas, vari√°veis e rela√ß√µes usando equa√ß√µes, inequa√ß√µes ou outras estruturas matem√°ticas.<br/>
 Exemplo simples: Considere um problema onde voc√™ deseja calcular a √°rea de um terreno retangular. Voc√™ pode modelar esse problema usando a f√≥rmula matem√°tica para calcular a √°rea de um ret√¢ngulo: √Årea = Comprimento x Largura. Aqui, voc√™ est√° traduzindo um problema do mundo real (calcular a √°rea do terreno) em uma equa√ß√£o matem√°tica.<br/>
 Exemplo pr√°tico:
```Python
# Exemplo de modelagem matem√°tica para calcular a √°rea de um terreno retangular

# Defini√ß√£o das vari√°veis (comprimento e largura)
comprimento = 10  # metros
largura = 5       # metros

# Modelagem matem√°tica (equa√ß√£o para calcular a √°rea)
area = comprimento * largura

# Impress√£o do resultado
print("√Årea do terreno: ", area, " metros quadrados")
```

 **2. Otimiza√ß√£o:**<br/>
 √â o processo de encontrar a melhor solu√ß√£o poss√≠vel para um problema, sujeito a um conjunto de restri√ß√µes. Em outras palavras, √© encontrar o valor m√°ximo ou m√≠nimo de uma fun√ß√£o objetivo dentro de um espa√ßo de busca.<br/>
 Exemplo simples: Suponha que voc√™ tenha uma quantidade fixa de dinheiro e queira comprar a maior quantidade poss√≠vel de frutas com esse dinheiro. Aqui, o objetivo √© maximizar a quantidade de frutas compradas, sujeito ao or√ßamento dispon√≠vel.<br/>
 Exemplo pr√°tico:
```Python
# Exemplo de otimiza√ß√£o para comprar frutas com um or√ßamento fixo

frutas = ["ma√ß√£", "banana", "laranja", "uva"]
precos = {"ma√ß√£": 2, "banana": 1, "laranja": 1.5, "uva": 3}

# Or√ßamento dispon√≠vel
orcamento = 10

# Modelagem matem√°tica (fun√ß√£o objetivo: maximizar a quantidade de frutas compradas)
# e restri√ß√£o (or√ßamento)
problem = LpProblem("Maximizar_Frutas", LpMaximize)
quantidade_frutas = LpVariable.dicts("Quantidade", frutas, lowBound=0, cat="Integer")
problem += lpSum([quantidade_frutas[fruta] for fruta in frutas]), "Total_Frutas"
problem += lpSum([precos[fruta] * quantidade_frutas[fruta] for fruta in frutas]) <= orcamento, "Restri√ß√£o_Orcamento"

# Resolvendo o problema de otimiza√ß√£o
problem.solve()

# Imprimindo a quantidade √≥tima de cada fruta
for fruta in frutas:
    print(fruta, ":", quantidade_frutas[fruta].varValue)

# Imprimindo o resultado
print("Quantidade total de frutas compradas: ", value(problem.objective))
```

 **3. √Ålgebra Linear:**<br/>
 Ramo da matem√°tica que estuda vetores, espa√ßos vetoriais e transforma√ß√µes lineares entre esses espa√ßos. Envolve opera√ß√µes como adi√ß√£o de vetores, multiplica√ß√£o por escala, multiplica√ß√£o de matrizes e resolu√ß√£o de sistemas de equa√ß√µes lineares.<br/>
 Exemplo simples: Imagine que voc√™ est√° em uma viagem de carro e quer calcular a dist√¢ncia total percorrida. Voc√™ pode dividir a viagem em v√°rias etapas e calcular a dist√¢ncia percorrida em cada etapa. Em seguida, voc√™ pode somar todas essas dist√¢ncias para obter a dist√¢ncia total percorrida. Aqui, voc√™ est√° realizando opera√ß√µes de adi√ß√£o, que s√£o conceitos fundamentais em √°lgebra linear.<br/>
 Exemplo pr√°tico:
```Python
# Exemplo de √°lgebra linear para calcular a dist√¢ncia total percorrida em uma viagem

# Dist√¢ncias percorridas em cada etapa da viagem (em quil√¥metros)
distancias = [50, 30, 40, 20, 60]

# Calculando a dist√¢ncia total percorrida (soma das dist√¢ncias em cada etapa)
distancia_total = sum(distancias)

# Imprimindo o resultado
print("Dist√¢ncia total percorrida: ", distancia_total, " quil√¥metros")
```

 **4. C√°lculo diferencial e integral:**<br/>
 √â um ramo da matem√°tica que estuda as taxas de mudan√ßa de fun√ß√µes (c√°lculo diferencial) e a acumula√ß√£o de quantidades (c√°lculo integral). Envolve conceitos como derivadas, integrais, limites e s√©ries infinitas.<br/>
 Exemplo simples: Considere um carro viajando em linha reta. A velocidade do carro pode ser representada como uma fun√ß√£o do tempo. O c√°lculo diferencial permite calcular a taxa de varia√ß√£o da velocidade em rela√ß√£o ao tempo, ou seja, a acelera√ß√£o do carro. Por outro lado, o c√°lculo integral permite calcular a dist√¢ncia total percorrida pelo carro ao longo do tempo, integrando a fun√ß√£o da velocidade.<br/>
 Para ilustrar o c√°lculo diferencial, podemos usar bibliotecas como SymPy ou scipy para calcular derivadas de fun√ß√µes. Por exemplo, vamos calcular a derivada da fun√ß√£o f(x) = x¬≤.<br/>
 Exemplo pr√°tico:
```Python
from sympy import symbols, diff

# Defini√ß√£o da vari√°vel e da fun√ß√£o
x = symbols('x')
f = x**2

# C√°lculo da derivada
derivada = diff(f, x)

# Impress√£o do resultado
print("Derivada de f(x) = ", derivada)
```

 Para ilustrar o c√°lculo integral, tamb√©m podemos usar as mesmas bibliotecas. Vamos calcular a integral definida da fun√ß√£o g(x) = x de 0 a 1:

```Python
from scipy import integrate

# Defini√ß√£o da fun√ß√£o
def g(x):
    return x

# C√°lculo da integral definida
integral, erro = integrate.quad(g, 0, 1)

# Impress√£o do resultado
print("Integral definida de g(x) de 0 a 1 = ", integral)
```

 **5. Teoria dos Grafos:**<br/>
 Ramo da matem√°tica que estuda as propriedades dos grafos, que s√£o estruturas compostas por v√©rtices (ou n√≥s) conectados por arestas (ou arcos). Ela investiga problemas como caminhos, circuitos, conectividade e colora√ß√£o de grafos.<br/>
 Exemplo: Imagine uma rede de computadores, onde os computadores s√£o representados como v√©rtices e as conex√µes entre eles s√£o representadas como arestas. A teoria dos grafos pode ser usada para encontrar o caminho mais curto entre dois computadores, determinar se a rede est√° conectada ou encontrar a maneira mais eficiente de transmitir dados.<br/>
 Podemos usar bibliotecas como NetworkX para trabalhar com grafos em Python. Por exemplo, vamos criar um grafo simples e calcular o caminho mais curto entre dois v√©rtices.<br/>
 Exemplo pr√°tico:
```Python
import networkx as nx

# Criando um grafo
grafo = nx.Graph()
grafo.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 5)])

# Calculando o caminho mais curto entre os v√©rtices 1 e 5
caminho_curto = nx.shortest_path(grafo, source=1, target=5)

# Impress√£o do resultado
print("Caminho mais curto entre os v√©rtices 1 e 5: ", caminho_curto)
```

 **6. Algoritmos de Otimiza√ß√£o:**<br/>
 S√£o m√©todos computacionais utilizados para encontrar a melhor solu√ß√£o poss√≠vel para um problema, sujeito a um conjunto de restri√ß√µes. Eles podem ser usados para maximizar ou minimizar uma fun√ß√£o objetivo, explorando diferentes combina√ß√µes de vari√°veis de decis√£o para encontrar a solu√ß√£o √≥tima.<br/>
 Exemplo: Considere o problema de encontrar o caminho mais curto entre dois pontos em um mapa. Algoritmos de otimiza√ß√£o podem ser usados para encontrar o caminho mais curto, levando em considera√ß√£o fatores como dist√¢ncia, tempo e custo.<br/>
 Um exemplo comum de algoritmo de otimiza√ß√£o √© o algoritmo gen√©tico, que √© a t√©cnica de busca inspirada na evolu√ß√£o biol√≥gica. Vamos usar a biblioteca DEAP para resolver um problema de minimiza√ß√£o simples.<br/>
 Exemplo pr√°tico:
```Python
from deap import base, creator, tools, algorithms

# Define o tipo de problema (minimiza√ß√£o)
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Fun√ß√£o de avalia√ß√£o (objetivo a ser minimizado)
def evaluate(individual):
    return sum(individual),

# Configura√ß√£o do problema
toolbox = base.Toolbox()
toolbox.register("attr_bool", random.randint, 0, 1)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", evaluate)

# Configura√ß√£o do algoritmo gen√©tico
population = toolbox.population(n=100)
algorithms.eaSimple(population, toolbox, cxpb=0.5, mutpb=0.2, ngen=50, verbose=False)

# Imprime a melhor solu√ß√£o encontrada
best_individual = tools.selBest(population, k=1)[0]
print("Melhor solu√ß√£o: ", best_individual)
```
 **Este exemplo usa o algoritmo gen√©tico para encontrar a melhor combina√ß√£o de bits que minimiza a soma dos valores.*

 **7. Ferramentas de Modelagem e Solu√ß√£o:**<br/>
 S√£o softwares e bibliotecas espec√≠ficas, projetadas para facilitar a modelagem e a resolu√ß√£o de problemas de otimiza√ß√£o. Elas oferecem uma interface conveniente para definir vari√°veis, restri√ß√µes e fun√ß√µes objetivo, al√©m de implementar algoritmos de solu√ß√£o eficientes.<br/>
 Exemplo simples: Imagine que voc√™ tem um problema de programa√ß√£o linear e deseja resolver utilizando uma ferramenta de modelagem e solu√ß√£o. Voc√™ pode usar uma linguagem de modelagem, como AMPL ou GAMS, para definir o problema de forma clara e concisa, e ent√£o usar um solucionador, como CPLEX ou Gurobi, para encontrar a solu√ß√£o √≥tima.<br/>
 Usando a biblioteca Pyomo para modelar, vamos resolver um problema de otimiza√ß√£o linear em Python. Suponha que queremos maximizar o lucro de uma fazenda que produz dois tipos de culturas: trigo e milho. Cada hectare de trigo gera um lucro de $200, enquanto cada hectare de milho gera um lucro de $300. No entanto, a fazenda tem uma limita√ß√£o de 500 horas de trabalho dispon√≠veis e 1000 unidades de fertilizante. Al√©m disso, sabemos que o trigo precisa de 2h de trabalho e 3 unidades de fertilizante por hectare, enquanto o milho precisa de 4 horas de trabalho e 2 unidades de fertilizante por hectare.<br/>
 Exemplo pr√°tico:
```Python
from pyomo.environ import *

# Criando o modelo de otimiza√ß√£o
modelo = ConcreteModel()

# Definindo as vari√°veis de decis√£o (hectares de trigo e milho)
modelo.x = Var(['Trigo', 'Milho'], domain=NonNegativeReals)

# Definindo a fun√ß√£o objetivo (maximizar o lucro)
modelo.objetivo = Objective(expr = 200*modelo.x['Trigo'] + 300*modelo.x['Milho'], sense=maximize)

# Definindo as restri√ß√µes (horas de trabalho e fertilizante)
modelo.restricao_trabalho = Constraint(expr = 2*modelo.x['Trigo'] + 4*modelo.x['Milho'] <= 500)
modelo.restricao_fertilizante = Constraint(expr = 3*modelo.x['Trigo'] + 2*modelo.x['Milho'] <= 1000)

# Resolvendo o problema de otimiza√ß√£o
solver = SolverFactory('glpk')
resultados = solver.solve(modelo)

# Imprimindo os resultados
print("Status da solu√ß√£o: ", resultados.solver.status)
print("Valor √≥timo da fun√ß√£o objetivo (lucro): ", value(modelo.objetivo))
print("Quantidade √≥tima de trigo (hectares): ", value(modelo.x['Trigo']))
print("Quantidade √≥tima de milho (hectares): ", value(modelo.x['Milho']))
```
 Neste exemplo, usamos a biblioteca Pyomo para definir o modelo de otimiza√ß√£o, incluindo vari√°veis de decis√£o, fun√ß√£o objetivo e restri√ß√µes. Em seguida, resolvemos o problema de otimiza√ß√£o usando o solver GLPK (GNU Linear Programming Kit). Os resultados incluem o status da solu√ß√£o, o valor √≥timo da fun√ß√£o objetivo (lucro) e as quantidades √≥timas de trigo e milho a serem plantadas.

 Em resumo, o paradigma de programa√ß√£o matem√°tico √© uma abordagem na qual os problemas s√£o formulados e resolvidos usando conceitos e t√©cnicas da matem√°tica. Ele se baseia em modelos matem√°ticos precisos para representar problemas do mundo real e usar algoritmos de otimiza√ß√£o para encontrar solu√ß√µes eficientes para esses problemas. Este paradigma est√° intimamente relacionado √† l√≥gica matem√°tica e √† l√≥gica combinat√≥ria.<br/>
 Na l√≥gica matem√°tica, estudamos princ√≠pios de racioc√≠nio v√°lido e infer√™ncia, al√©m de conceitos como l√≥gica de predicados, l√≥gica proposicional, teoria dos modelos e teoria dos conjuntos. Esses conceitos s√£o fundamentais para a formula√ß√£o e a valida√ß√£o de modelos matem√°ticos utilizados na programa√ß√£o matem√°tica.<br/>
 Por outro lado, a l√≥gica combinat√≥ria se preocupa com a an√°lise e a enumera√ß√£o de diferentes possibilidades de arranjos, combina√ß√µes  e permuta√ß√µes de elementos em conjuntos finitos. Ela fornece t√©cnicas para contar e enumerar possibilidades, o que √© √∫til na an√°lise de problemas de programa√ß√£o matem√°tica que envolvem escolhas discretas e estruturas combinat√≥rias.<br/>
 O paradigma de programa√ß√£o matem√°tico n√£o √© uma categoria de paradigma de programa√ß√£o como a programa√ß√£o reativa, mas sim uma abordagem para resolver problemas computacionais usando conceitos e t√©cnicas da matem√°tica. Portanto, todas as linguagens de programa√ß√£o podem ser usadas para implementar algoritmos e solu√ß√µes baseadas em matem√°tica.<br/>
 No entanto, algumas linguagens de programa√ß√£o t√™m recursos embutidos ou bibliotecas especializadas que tornam mais f√°cil expressar e resolver problemas matem√°ticos. Aqui est√£o algumas linguagens de programa√ß√£o comuns que s√£o frequentemente usadas para implementar solu√ß√µes baseadas em matem√°tica: Matlab (linguagem de programa√ß√£o e ambiente de desenvolvimento voltado para c√°lculos num√©ricos e computa√ß√£o t√©cnica. Ele √© frequentemente usado em engenharia, matem√°tica aplicada e ci√™ncias naturais), GNU Octave (√© um ambiente de computa√ß√£o num√©rica de c√≥digo aberto, semelhante ao MATLAB. Ele √© usado para resolver problemas matem√°ticos e realizar an√°lises num√©ricas, modelagem e simula√ß√µes), Mathematica (√© um sistema de √°lgebra computacional usado em muitas √°reas da ci√™ncia, engenharia e matem√°tica. Ele fornece uma ampla gama de funcionalidades matem√°ticas e √© frequentemente usado para simula√ß√µes, visualiza√ß√µes e an√°lises simb√≥licas), Maple (√© outro sistema de √°lgebra computacional que √© usado para uma variedade de tarefas matem√°ticas, incluindo c√°lculos simb√≥licos, num√©ricos e visualiza√ß√µes. Ele √© popular entre os pesquisadores e profissionais que trabalham em matem√°tica, engenharia e ci√™ncias aplicadas), SageMath (linguagem de programa√ß√£o e ambiente de software matem√°tico que integra v√°rias bibliotecas e ferramentas de c√≥digo aberto. Ele fornece uma ampla gama de funcionalidades matem√°ticas, incluindo √°lgebra, c√°lculo, estat√≠stica, visualiza√ß√£o e muito mais), Maxima (√© um sistema de √°lgebra computacional de c√≥digo aberto baseado em Lisp. Ele √© usado para realizar c√°lculos simb√≥licos e num√©ricos, resolver equa√ß√µes, integrar e diferenciar fun√ß√µes, entre outras opera√ß√µes matem√°ticas), Scilab (linguagem de programa√ß√£o e ambiente de computa√ß√£o num√©rica usado para an√°lise de dados, modelagem matem√°tica, simula√ß√µes e visualiza√ß√µes. Ele oferece uma ampla variedade de fun√ß√µes matem√°ticas e √© frequentemente usado em engenharia e ci√™ncias aplicadas), Python, R, Julia, Fortran e C/C++.<br/>
 Portanto, para se tornar proficiente no paradigma de programa√ß√£o matem√°tico, √© essencial entender e dominar os conceitos fundamentais da l√≥gica matem√°tica, como l√≥gica proposicional, l√≥gica de predicados e teoria dos modelos, bem como os princ√≠pios b√°sicos da l√≥gica combinat√≥ria, como permuta√ß√µes, combina√ß√µes e princ√≠pios de contagem. Al√©m disso, √© importante familiarizar-se com ferramentas de modelagem e solu√ß√£o, algoritmos de otimiza√ß√£o e t√©cnicas de √°lgebra linear e c√°lculo diferencial e integral, que s√£o amplamente utilizados na resolu√ß√£o de problemas de programa√ß√£o matem√°tica.

#### COMPUTA√á√ÉO PARALELA
 O processamento paralelo √© uma t√©cnica que envolve a execu√ß√£o simult√¢nea de m√∫ltiplas tarefas computacionais e ajuda a reduzir o tempo de execu√ß√£o da instru√ß√£o com o objetivo de reduzir o tempo de execu√ß√£o e melhorar o desempenho do sistema. Ele faz isso dividindo um problema em partes menores, compartilhando ou paralelizando instru√ß√µes entre v√°rios processadores, que s√£o processadas independentemente por diferentes processadores ou n√∫cleos de processamento. O significado da abordagem pode ser resumido em uma frase: *"dividir e conquistar"* onde um problema √© dividido em partes menores, que s√£o ent√£o resolvidas independentemente e combinadas para produzir a solu√ß√£o final.<br/>
 Ao contr√°rio da computa√ß√£o concorrente, onde as tarefas s√£o alternadas ao longo do tempo, na computa√ß√£o paralela, as tarefas s√£o realmente executadas ao mesmo tempo, semelhante ao paradigma de computa√ß√£o distribu√≠da, com a diferen√ßa que a execu√ß√£o simult√¢nea de m√∫ltiplas tarefas acontece na mesma m√°quina usando diferentes processadores ou n√∫cleos de processamento, o que pode levar a um aumento significativo no desempenho e na capacidade de processamento.<br/>
 Exemplos de linguagens de programa√ß√£o que suportam processamento paralelo s√£o NESL (uma das mais antigas) e C/C++ (tamb√©m suportada devido a algumas fun√ß√µes de biblioteca).<br/>
 Imagine que voc√™ tenha uma lista grande de n√∫meros e queira calcular a soma de todos eles. Em vez de calcular a soma sequencialmente, voc√™ pode dividir a lista em partes menores e distribuir essas partes para diferentes processadores. Cada processador calcular√° a soma de sua parte e, em seguida, os resultados parciais ser√£o combinados para obter a soma total.<br/>
 Aqui est√° um exemplo em C++ usando a biblioteca `<thread>` para demonstrar processamento paralelo:
```C++
#include <iostream>
#include <vector>
#include <thread>

// Fun√ß√£o para calcular a soma de uma parte da lista
int calcularSoma(const std::vector<int>& nums, int inicio, int fim) {
    int soma = 0;
    for (int i = inicio; i < fim; ++i) {
        soma += nums[i];
    }
    return soma;
}

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int tamanho_parte = numeros.size() / 2;

    // Criar threads para calcular a soma de partes diferentes da lista
    int soma_parcial1 = 0;
    int soma_parcial2 = 0;
    std::thread t1([&]() { soma_parcial1 = calcularSoma(numeros, 0, tamanho_parte); });
    std::thread t2([&]() { soma_parcial2 = calcularSoma(numeros, tamanho_parte, numeros.size()); });

    // Esperar pelas threads terminarem
    t1.join();
    t2.join();

    // Calcular a soma total combinando as somas parciais
    int soma_total = soma_parcial1 + soma_parcial2;

    std::cout << "Soma total: " << soma_total << std::endl;

    return 0;
}
```
 Neste exemplo, a lista de n√∫meros √© dividida em duas partes, e cada parte √© processada em uma thread separada usando a fun√ß√£o `calcularSoma()`. As somas parciais s√£o ent√£o combinadas para obter a soma total. Este √© um exemplo b√°sico de processamento paralelo em C++.

##### SUPORTES
 Al√©m das linguagens j√° mencionadas, v√°rias outras linguagens suportam computa√ß√£o paralela. Algumas delas incluem:
 1. *Java*: Java oferece suporte √† programa√ß√£o paralela por meio de APIs como Java Threads, Executor Framework e Fork/Join Framework. Al√©m disso, a plataforma Java possui a API Java Parallel Streams, introduzida no Java 8, que facilita a paraleliza√ß√£o de opera√ß√µes em cole√ß√µes.
 2. *Python*: Embora Python seja uma linguagem de programa√ß√£o de alto n√≠vel, ela oferece suporte √† computa√ß√£o paralela por meio de bibliotecas como threading, multiprocessing e concurrent.futures. Al√©m disso, bibliotecas como NumPy e pandas s√£o otimizadas para opera√ß√µes paralelas em arrays e dataframes, respectivamente.
 3. *Rust*: Rust √© uma linguagem de programa√ß√£o de sistema que oferece seguran√ßa de mem√≥ria e concorr√™ncia sem necessidade de coleta de lixo. Ela possui um sistema de tipo exclusivo chamado *"ownership"* que permite a paraleliza√ß√£o segura de c√≥digo.
 4. *Go*: Go √© uma linguagem de programa√ß√£o desenvolvida pelo Google, projetada para facilitar a programa√ß√£o concorrente e paralela. Ela possui primitivas de concorr√™ncia incorporadas, como goroutines e canais, que facilitam a escrita de c√≥digo paralelo.
 5. *CUDA*: Embora n√£o seja uma linguagem de programa√ß√£o convencional, CUDA (Compute Unified Device Architecture) √© uma arquitetura de computa√ß√£o paralela desenvolvida pela NVIDIA. Ela permite que programadores escrevam c√≥digo em C/C++ para ser executado em GPUs NVIDIA, aproveitando o poder de processamento paralelo das GPUs.
 6. *MATLAB*: MATLAB √© uma linguagem de programa√ß√£o amplamente utilizada em computa√ß√£o num√©rica e engenharia. Ela oferece suporte a paralelismo por meio do MATLAB Parallel Computing Toolbox, que permite a execu√ß√£o de c√≥digo MATLAB em paralelo em clusters de computadores e em m√∫ltiplos n√∫cleos de CPU.
 7. *Julia*: Julia √© uma linguagem de programa√ß√£o de alto desempenho para computa√ß√£o t√©cnica e cient√≠fica. Ela √© projetada para ser r√°pida e eficiente, com suporte integrado para computa√ß√£o paralela por meio de primitivas de concorr√™ncia e pacotes como Threads.jl e Distributed.jl.
 8. *OpenMP*: OpenMP √© uma API de programa√ß√£o de mem√≥ria compartilhada para C, C++ e Fortran. Ela permite a cria√ß√£o de c√≥digos paralelos por meio de diretivas de compilador, que s√£o interpretadas por compiladores que suportam OpenMP para gerar c√≥digo paralelo.
 9. *MPI* (Message Passing Interface): MPI √© uma especifica√ß√£o de comunica√ß√£o de dados em sistemas paralelos e distribu√≠dos. Embora n√£o seja uma linguagem de programa√ß√£o por si s√≥, MPI √© comumente usada com linguagens como C, C++, Fortran e Python para criar aplicativos paralelos e distribu√≠dos.
 10. *Haskell*: Haskell √© uma linguagem de programa√ß√£o funcional pura que oferece suporte √† computa√ß√£o paralela por meio de primitivas de concorr√™ncia e bibliotecas como Control.Parallel e parMap.
 11. *Scala*: Scala √© uma linguagem de programa√ß√£o multiparadigma que √© executada na JVM (Java Virtual Machine). Ela oferece suporte √† computa√ß√£o paralela por meio de constru√ß√µes como Futures e Promises, bem como pela biblioteca Akka, que fornece um modelo de ator para concorr√™ncia.
 12. *Fortran*: Fortran √© uma linguagem de programa√ß√£o amplamente utilizada em computa√ß√£o cient√≠fica e de engenharia. Ela oferece suporte √† computa√ß√£o paralela por meio de bibliotecas como OpenMP e MPI, bem como por meio de primitivas de concorr√™ncia nativas.
 13. *Apache* Spark: Um framework de computa√ß√£o em cluster projetado para an√°lise de big data, Spark oferece APIs em v√°rias linguagens, incluindo Scala, Java, Python e R, para processamento paralelo distribu√≠do.
 14. *Hadoop*: Um ecossistema de software para computa√ß√£o distribu√≠da em clusters de computadores, Hadoop inclui o Hadoop MapReduce, um modelo de programa√ß√£o para processamento paralelo de grandes conjuntos de dados distribu√≠dos em clusters.

 Essas s√£o apenas algumas das linguagens e bibliotecas que oferecem recursos para aproveitar o poder do processamento paralelo. Dependendo das necessidades e requisitos do projeto, diferentes linguagens e ferramentas podem ser mais adequadas para implementar solu√ß√µes paralelas e aproveitar ao m√°ximo a capacidade de processamento de hardware moderno.

#### COMPUTA√á√ÉO DISTRIBU√çDA
 Na computa√ß√£o distribu√≠da, as tarefas s√£o distribu√≠das entre v√°rios dispositivos ou sistemas de computa√ß√£o em uma rede. Cada dispositivo ou sistema pode operar de forma independente e coordenar suas atividades com outros dispositivos por meio de comunica√ß√£o em rede. A computa√ß√£o distribu√≠da √© frequentemente usada em sistemas distribu√≠dos, como sistemas de armazenamento em nuvem, redes de sensores e processamento de big data.<br/>
 A computa√ß√£o distribu√≠da √© um paradigma de programa√ß√£o que envolve a execu√ß√£o de tarefas em sistemas distribu√≠dos, fun√ß√µes executadas de forma independente, compostos por m√∫ltiplos dispositivos de computa√ß√£o interconectados, como computadores, servidores, dispositivos m√≥veis e sensores. Nesse paradigma, as tarefas s√£o distribu√≠das entre os diferentes n√≥s do sistema, que trabalham em conjunto para alcan√ßar um objetivo comum.<br/>
 A programa√ß√£o de sistemas distribu√≠dos envolve o desenvolvimento de software que √© projetado para ser executado em um ambiente distribu√≠do. Isso pode envolver a escolha de linguagens de programa√ß√£o adequadas, estruturas de programa√ß√£o distribu√≠da (como modelos de ator ou arquiteturas baseadas em eventos), e o uso de bibliotecas e ferramentas para facilitar a comunica√ß√£o e a coordena√ß√£o entre os n√≥s.<br/>
 Um exemplo simples de computa√ß√£o distribu√≠da seria um sistema de armazenamento de arquivos distribu√≠do, onde v√°rios servidores armazenam partes de um arquivo e os clientes se comunicam com esses servidores para ler ou gravar dados.<br/>
 Um exemplo pr√°tico de computa√ß√£o distribu√≠da seria o desenvolvimento de um sistema de processamento de big data usando a estrutura Apache Hadoop. Nesse sistema, os dados s√£o divididos e processados em paralelo em um cluster de computadores distribu√≠dos, usando o modelo de programa√ß√£o MapReduce para processamento distribu√≠do.

##### PRINCIPAIS PONTOS
 Aqui est√£o alguns dos principais aspectos e conceitos associados √† programa√ß√£o de computa√ß√£o distribu√≠da:
 1. *Comunica√ß√£o*: Os diferentes n√≥s de um sistema distribu√≠do precisam se comunicar entre si para coordenar suas atividades e trocar dados. A comunica√ß√£o pode ser realizada por meio de redes locais ou de longa dist√¢ncia, usando protocolos de comunica√ß√£o como TCP/IP, UDP e HTTP.
 2. *Coordena√ß√£o*: A coordena√ß√£o √© essencial para garantir que os diferentes n√≥s de um sistema distribu√≠do trabalhem de forma colaborativa e eficiente. Isso envolve a sincroniza√ß√£o de tarefas, a resolu√ß√£o de conflitos e a garantia de consist√™ncia nos dados compartilhados.
 3. *Toler√¢ncia a falhas*: Como os sistemas distribu√≠dos s√£o compostos por m√∫ltiplos n√≥s, √© importante que eles sejam capazes de lidar com falhas de forma robusta e resiliente. Isso pode envolver a detec√ß√£o de falhas, a recupera√ß√£o autom√°tica e a redund√¢ncia de dados e servi√ßos.
 4. *Escalabilidade*: A escalabilidade √© a capacidade de um sistema distribu√≠do de lidar com um aumento no n√∫mero de usu√°rios, dados ou carga de trabalho sem comprometer o desempenho ou a disponibilidade. Isso pode ser alcan√ßado por meio da adi√ß√£o de mais n√≥s ao sistema ou da distribui√ß√£o de carga entre os n√≥s existentes.
 5. *Seguran√ßa*: A seguran√ßa √© uma preocupa√ß√£o importante na programa√ß√£o de computa√ß√£o distribu√≠da, uma vez que os dados e recursos do sistema podem estar sujeitos a amea√ßas como acesso n√£o autorizado, intercepta√ß√£o de dados e ataques de nega√ß√£o de servi√ßo. Medidas de seguran√ßa, como autentica√ß√£o, criptografia e controle de acesso, s√£o essenciais para proteger o sistema contra essas amea√ßas.

 Um exemplo simples de computa√ß√£o distribu√≠da seria um sistema de processamento de pedidos em uma loja online, onde diferentes servidores lidam com fun√ß√µes espec√≠ficas, como processamento de pagamentos, gerenciamento de estoque e envio de pedidos.<br/>
 Outro exemplo pr√°tico em Python usando a biblioteca asyncio para implementar um servidor TCP simples que recebe mensagensde clientes e as retransmite para todos os outros clientes conectados:
```Python
import asyncio

clients = set()

async def handle_client(reader, writer):
    clients.add(writer)
    try:
        while True:
            data = await reader.read(100)
            if not data:
                break
            for client in clients:
                client.write(data)
                await client.drain()
    finally:
        clients.remove(writer)
        writer.close()

async def main():
    server = await asyncio.start_server(
        handle_client, '127.0.0.1', 8888)
    async with server:
        await server.serve_forever()

asyncio.run(main())
```
 Este √© um servidor de eco muito simples que recebe mensagens de clientes e retransmite essas mensagens para todos os outros clientes conectados. Ele usa a biblioteca asyncio para lidar com E/S ass√≠ncrona, permitindo que o servidor atenda a m√∫ltiplos clientes simultaneamente.

Linguagens que suportam este paradigma:
- Python (com asyncio)
- Java (com Java RMI e Java Message Service)
- C# (com .NET Remoting e Windows Communication Foundation)
- Erlang (desenvolvida para programa√ß√£o distribu√≠da)
- Scala (com Akka)
- Rust (com RustActors)
- Go (com pacotes de comunica√ß√£o de rede padr√£o)
- Haskell (com Cloud Haskell)
- Ruby (com DRb e Rinda)

 Essas s√£o apenas algumas das linguagens que suportam o paradigma de programa√ß√£o de computa√ß√£o distribu√≠da. Cada uma oferece suas pr√≥prias bibliotecas e ferramentas para facilitar o desenvolvimento de sistemas distribu√≠dos.

#### COMPUTA√á√ÉO CONCORRENTE
 O paradigma de programa√ß√£o de computa√ß√£o concorrente envolve o desenvolvimento de software que executa m√∫ltiplas tarefas concorrentemente ou seja, executa tarefas de forma intercalada de acordo com: a disponibilidade do sistema, a depend√™ncia entre as tarefas, o grau de conclus√£o da tarefa em execu√ß√£o ou o grau das prioridades (din√¢mica). A computa√ß√£o concorrente lida com m√∫ltiplas tarefas que podem ser executadas ao mesmo tempo, mas n√£o necessariamente simultaneamente.<br/>
 Na computa√ß√£o concorrente, m√∫ltiplas tarefas s√£o executadas de forma intercalada ao longo do tempo. Isso permite que programaslidem com diversas opera√ß√µes simultaneamente, mesmo em sistemas de processamento √∫nico. A concorr√™ncia √© frequentemente usada para melhorar a capacidade de resposta e a efici√™ncia dos sistemas, especialmente em situa√ß√µes onde v√°rias tarefas precisam ser realizadas ao mesmo tempo.<br/>

 Aqui est√£o os principais aspectos e conceitos associados a esse paradigma:
 1. **Processos e Threads**: Um processo √© uma inst√¢ncia em execu√ß√£o de um programa, enquanto um thread √© uma unidade de execu√ß√£o dentro de um processo. A computa√ß√£o concorrente geralmente envolve a cria√ß√£o de m√∫ltiplos threads dentro de um processo para realizar tarefas simultaneamente.
 2. **Compartilhamento de Recursos**: Os threads compartilham recursos, como mem√≥ria e arquivos, dentro de um processo. O acesso concorrente a esses recursos requer sincroniza√ß√£o para evitar condi√ß√µes de corrida e garantir a consist√™ncia dos dados.
 3. **Sincroniza√ß√£o e Coordena√ß√£o**: Mecanismos de sincroniza√ß√£o, como sem√°foros, mutexes e monitores, s√£o usados para coordenar a execu√ß√£o concorrente de threads e garantir a consist√™ncia dos dados compartilhados.
 4. **Concorr√™ncia vs. Paralelismo**: Concorr√™ncia refere-se √† capacidade de v√°rios threads progredirem simultaneamente, enquanto paralelismo refere-se √† execu√ß√£o simult√¢nea real desses threads em m√∫ltiplos n√∫cleos de processamento.
 5. **Modelos de Concorr√™ncia**: Existem v√°rios modelos de concorr√™ncia, incluindo programa√ß√£o baseada em eventos, programa√ß√£o orientada a tarefas e programa√ß√£o baseada em fluxo de dados. Cada modelo tem suas pr√≥prias caracter√≠sticas e abordagens para lidar com a concorr√™ncia.

##### PRIORIZA√á√ÉO DE TAREFAS
 Na computa√ß√£o concorrente, a prioriza√ß√£o e a sequ√™ncia de execu√ß√£o de tarefas s√£o determinadas por meio de diferentes t√©cnicas de agendamento, dependendo do sistema operacional e do modelo de concorr√™ncia utilizado:
 - *Preemptivo vs. Cooperativo*: Em sistemas concorrentes preemptivos, o sistema operacional pode interromper uma tarefa em andamento para permitir a execu√ß√£o de outra tarefa de maior prioridade. Por outro lado, em sistemas cooperativos, as tarefas precisam cooperar explicitamente, cedendo o controle ao sistema operacional ou a outras tarefas.
 - *Prioridade de Tarefas*: As tarefas podem ser atribu√≠das a diferentes prioridades, e o agendador do sistema operacional decide qual tarefa deve ser executada com base nessas prioridades. Tarefas com prioridade mais alta tendem a ser executadas antes das tarefas com prioridade mais baixa.
 - *Round-Robin*: Este √© um algoritmo de agendamento simples onde as tarefas s√£o executadas em turnos. Cada tarefa recebe um intervalo de tempo de CPU chamado de fatia de tempo e as tarefas s√£o alternadas em execu√ß√£o at√© que todas sejam conclu√≠das.
 - *Fila de Prontid√£o*: As tarefas s√£o colocadas em uma fila de prontid√£o e o agendador do sistema operacional escolhe a pr√≥xima tarefa a ser executada a partir dessa fila.
 - *Aloca√ß√£o Justa de Recursos*: Em sistemas que priorizam a justi√ßa na aloca√ß√£o de recursos, o agendador tenta garantir que todas as tarefas recebam uma quantidade justa de tempo de CPU.
 - *Algoritmos de Agendamento Personalizados*: Em alguns casos, sistemas espec√≠ficos podem implementar algoritmos de agendamento  personalizados para atender a requisitos espec√≠ficos de desempenho ou comportamento do sistema.

 Em resumo, a sequ√™ncia de execu√ß√£o das tarefas na computa√ß√£o concorrente √© determinada por uma combina√ß√£o de prioridades de tarefa, pol√≠ticas de agendamento do sistema operacional e algoritmos de agendamento utilizados.

###### DIFEREN√áAS
 - A computa√ß√£o concorrente lida com m√∫ltiplas tarefas que podem ser executadas ao mesmo tempo, mas n√£o necessariamente simultaneamente.
 - A computa√ß√£o paralela envolve a execu√ß√£o simult√¢nea de m√∫ltiplas tarefas em diferentes processadores ou n√∫cleos de processamento.
 - A computa√ß√£o distribu√≠da distribui tarefas entre v√°rios dispositivos ou sistemas de computa√ß√£o em uma rede, permitindo a coordena√ß√£o e colabora√ß√£o entre eles.

#### PROGRAMA√á√ÉO DE BANCO DE DADOS
 Derivado do paradigma declarativo por conta de sua forma de estrutura√ß√£o, a programa√ß√£o de banco de dados √© fundamentalmente baseada na manipula√ß√£o e gerenciamento de dados armazenados em um banco de dados, sendo descrito o resultado esperado, ou seja, "o que fazer" com este dados.<br/>
 Essa metodologia de programa√ß√£o √© baseada no trabalho com dados. Os dados s√£o armazenados no banco de dados e as consultas s√£o feitas a esse banco de dados em uma linguagem especial, por exemplo, SQL. Com essas linguagens, voc√™ pode acessar os dados para filtragem, transforma√ß√µes, c√°lculo de estat√≠sticas e assim por diante. As instru√ß√µes do programa s√£o definidas por dados, em vez de uma s√©rie de etapas embutidas em c√≥digo.<br/>
 O programa de banco de dados √© o cora√ß√£o do sistema de informa√ß√µes de neg√≥cios, permitindo a cria√ß√£o de arquivos, entrada de dados, atualiza√ß√£o, consulta e fun√ß√µes de relat√≥rio.

##### ASPECTOS IMPORTANTES
Aqui est√£o alguns aspectos importantes associados a esse paradigma:
 - *Linguagem SQL*: A Linguagem de Consulta Estruturada (SQL) √© a linguagem padr√£o para a intera√ß√£o com bancos de dados relacionais. Ela permite realizar opera√ß√µes como inser√ß√£o, consulta, atualiza√ß√£o e exclus√£o de dados em tabelas de um banco de dados.
 - *Modelagem de Dados*: Antes de implementar um banco de dados, √© necess√°rio projetar sua estrutura usando modelos de dados como o Modelo Entidade-Relacionamento (ER). Isso envolve identificar entidades, atributos e relacionamentos entre entidades.
 - *Opera√ß√µes CRUD*: As opera√ß√µes b√°sicas em um banco de dados s√£o conhecidas como CRUD, que significa Create (Criar), Read (Ler), Update  (Atualizar) e Delete (Excluir). Essas opera√ß√µes permitem manipular os dados armazenados no banco de dados.
 - *Normaliza√ß√£o*: A normaliza√ß√£o √© o processo de organiza√ß√£o dos dados em um banco de dados para reduzir a redund√¢ncia e melhorar a integridade dos dados. Isso envolve dividir as tabelas em estruturas mais granulares e estabelecer rela√ß√µes entre elas.
 - *√çndices e Restri√ß√µes*: √çndices s√£o estruturas que melhoram a velocidade de consulta em um banco de dados, enquanto as restri√ß√µes garantem a integridade dos dados, impondo regras sobre os valores que podem ser armazenados em determinadas colunas.
 - *Procedimentos Armazenados e Fun√ß√µes*: Procedimentos armazenados e fun√ß√µes s√£o blocos de c√≥digo SQL que podem ser armazenados no banco de dados e reutilizados em v√°rias consultas. Eles ajudam a modularizar a l√≥gica de neg√≥cios e melhorar a seguran√ßa dos dados.

 Um exemplo simples de programa√ß√£o de banco de dados seria a cria√ß√£o de uma tabela de clientes e a inser√ß√£o de dados nessa tabela usando SQL:
```SQL
CREATE TABLE Clientes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nome VARCHAR(50),
    email VARCHAR(50)
);

INSERT INTO Clientes (nome, email) VALUES ('Jo√£o', 'joao@example.com');
INSERT INTO Clientes (nome, email) VALUES ('Maria', 'maria@example.com');
```

 Vamos criar um banco de dados em SQLite usando Python e realizar algumas opera√ß√µes b√°sicas de CRUD (Criar, Ler, Atualizar, Excluir) utilizando Python/SQL.<br/>
 Primeiro, vamos criar um banco de dados SQLite chamado `clientes.db` e uma tabela chamada `dadosClientes` com as colunas id, nome e email. Em seguida, realizaremos opera√ß√µes para inserir, ler, atualizar e excluir registros nessa tabela.
```Python
import sqlite3

# Conectar ao banco de dados (se n√£o existir, ser√° criado)
conexao = sqlite3.connect('clientes.db')

# Criar uma tabela chamada 'dadosClientes'
cursor = conexao.cursor()
cursor.execute('''CREATE TABLE IF NOT EXISTS dadosClientes (
                    id INTEGER PRIMARY KEY,
                    nome TEXT NOT NULL,
                    email TEXT NOT NULL
                )''')
conexao.commit()

# Fun√ß√£o para inserir um novo cliente
def inserir_cliente(nome, email):
    cursor.execute('''INSERT INTO dadosClientes (nome, email) VALUES (?, ?)''', (nome, email))
    conexao.commit()
    print("Usu√°rio inserido com sucesso!")

# Fun√ß√£o para ler todos os clientes
def listar_dadosClientes():
    cursor.execute('''SELECT * FROM dadosClientes''')
    dadosClientes = cursor.fetchall()
    for cliente in dadosClientes:
        print(cliente)

# Fun√ß√£o para atualizar o email de um cliente
def atualizar_email(cliente_id, novo_email):
    cursor.execute('''UPDATE dadosClientes SET email = ? WHERE id = ?''', (novo_email, cliente_id))
    conexao.commit()
    print("Email atualizado com sucesso!")

# Fun√ß√£o para excluir um cliente
def excluir_cliente(cliente_id):
    cursor.execute('''DELETE FROM dadosClientes WHERE id = ?''', (cliente_id,))
    conexao.commit()
    print("Usu√°rio exclu√≠do com sucesso!")

# Exemplos de opera√ß√µes CRUD
inserir_cliente('D√©borah', 'deborah@example.com')
inserir_cliente('Raphael', 'raphael@example.com')
listar_dadosClientes()
atualizar_email(1, 'deborah@email.com')
excluir_cliente(2)
listar_dadosClientes()

# Fechar a conex√£o com o banco de dados
conexao.close()
```
 Este c√≥digo Python cria um banco de dados SQLite chamado `clientes.db` e uma tabela `dadosClientes`. Em seguida, ele insere dois clientes, lista todos os clientes, atualiza o email do primeiro cliente, exclui o segundo cliente e lista novamente os clientes para mostrar as altera√ß√µes.<br/>
 O paradigma de programa√ß√£o de banco de dados √© essencial para o desenvolvimento de sistemas de informa√ß√£o robustos e eficientes. Ele se baseia na manipula√ß√£o e consulta de dados armazenados em bancos de dados utilizando linguagens especializadas como SQL. Este paradigma permite a cria√ß√£o de sistemas que podem criar, atualizar, recuperar e manipular grandes volumes de dados de forma r√°pida e eficiente.<br/>
 A abordagem centrada em dados oferecida pela programa√ß√£o de banco de dados traz uma s√©rie de benef√≠cios, incluindo a capacidade de criar consultas complexas para filtrar e analisar dados, garantindo a integridade e consist√™ncia dos dados armazenados, e permitindo a gera√ß√£o de relat√≥rios e an√°lises que fornecem insights valiosos para tomada de decis√µes.<br/>
 Al√©m disso, a programa√ß√£o de banco de dados desempenha um papel fundamental no suporte a sistemas de informa√ß√£o de neg√≥cios, fornecendo a infraestrutura necess√°ria para armazenar e gerenciar dados relacionados a clientes, transa√ß√µes, invent√°rio e muito mais.<br/>
 Em suma, o paradigma de programa√ß√£o de banco de dados √© uma ferramenta poderosa para lidar com dados em sistemas de informa√ß√£o, oferecendo uma maneira eficiente e estruturada de trabalhar com informa√ß√µes vitais para organiza√ß√µes e aplicativos modernos.

#### PROGRAMA√á√ÉO ORIENTADO A ASPECTOS
 O paradigma de programa√ß√£o Orientado a Aspectos (Aspect-Oriented Programming - AOP) √© uma abordagem que visa a modulariza√ß√£o de preocupa√ß√µes transversais em uma aplica√ß√£o, como logging, seguran√ßa, transa√ß√µes, etc, separando essas preocupa√ß√µes do c√≥digo principal da aplica√ß√£o. Em vez de espalhar o c√≥digo relacionado a essas preocupa√ß√µes por todo o c√≥digo base, o AOP permite agrupar esse c√≥digo em "aspectos", que podem ser aplicados seletivamente ao c√≥digo principal.

##### ASPECTOS E CONCEITOS
Principais aspectos e conceitos associados ao AOP:
 - *Aspecto*: Um m√≥dulo que encapsula comportamentos que afetam v√°rias partes de um programa. Por exemplo, um aspecto de logging pode encapsular a l√≥gica para registrar informa√ß√µes de depura√ß√£o em v√°rios pontos do c√≥digo.
 - *Ponto de jun√ß√£o (Join Point)*: Pontos espec√≠ficos no c√≥digo onde um aspecto pode ser aplicado. Exemplos incluem chamadas de m√©todo, exce√ß√µes lan√ßadas ou vari√°veis sendo acessadas.
 - *Ponto de corte (Pointcut)*: Uma express√£o que define quais pontos de jun√ß√£o em um programa s√£o afetados por um aspecto. Por exemplo, um ponto de corte pode especificar que um aspecto de logging deve ser aplicado a todas as chamadas de m√©todos em uma determinada classe.
 - *Conselho (Advice)*: O c√≥digo que √© executado em um ponto de jun√ß√£o espec√≠fico quando um aspecto √© aplicado. Pode ser executado antes, depois ou em torno do ponto de jun√ß√£o.

 Considere um aspecto de logging que registra o tempo de execu√ß√£o de determinados m√©todos em uma aplica√ß√£o. O c√≥digo principal da aplica√ß√£o n√£o precisa se preocupar com essa l√≥gica de logging; ela √© encapsulada no aspecto.<br/>
 Exemplo pr√°tico em Python com uso da biblioteca `aspectlib`:
```Python
from aspectlib import Aspect

def log_execution_time(target_function):
    import time

    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = target_function(*args, **kwargs)
        end_time = time.time()
        print(f"{target_function.__name__} executed in {(end_time - start_time) * 1000}ms")
        return result

    return wrapper

with Aspect() as logging_aspect:
    logging_aspect(log_execution_time, across=['module'])

# Exemplo de uso
def example_function():
    import random
    import time
    time.sleep(random.uniform(0, 1))

example_function()
```
 Neste exemplo, usamos a biblioteca `aspectlib` para criar um aspecto de logging que mede o tempo de execu√ß√£o de todas as fun√ß√µes no m√≥dulo.

#### PROGRAMA√á√ÉO ORIENTADA A EVENTOS
 O paradigma de orienta√ß√£o a eventos √© usado por toda linguagem de programa√ß√£o que tem uso de recursos gr√°ficos, como jogos e formul√°rios. Dessa forma, a execu√ß√£o do programa se d√° a medida que determinados eventos s√£o disparados pelo usu√°rio. Portanto, quem usa √© respons√°vel pelo momento em que o programa √© executado.<br/>
 Imagine uma caixa de formul√°rio que precisa do preenchimento do usu√°rio. Os eventos descritos no c√≥digo fonte ser√£o executados √† medida que se realiza o preenchimento dos campos solicitados. Al√©m disso, ocorrem execu√ß√µes tamb√©m quando se decide enviar os dados clicando no bot√£o de envio. S√£o eventos que disparam outros eventos.

##### PRINCIPAIS CARACTER√çSTICAS
 Principais caracter√≠sticas e conceitos:
 1. *Eventos*: Representam a ocorr√™ncia de a√ß√µes ou mudan√ßas de estado que podem ser detectadas e processadas pelo programa. Exemplos de eventos incluem cliques de mouse, pressionamentos de tecla, envio de formul√°rios, etc.
 2. *Listeners (ou tratadores de eventos)*: S√£o fun√ß√µes ou m√©todos que s√£o associados a um determinado evento e s√£o acionados quando esse evento ocorre. Os ouvintes agem como observadores, aguardando a ocorr√™ncia de um evento espec√≠fico para responder a ele.
 3. *Loop de eventos*: √â uma estrutura de controle que aguarda a ocorr√™ncia de eventos e os despacha para os respectivos ouvintes. O loop de eventos √© respons√°vel por gerenciar a fila de eventos e garantir que eles sejam processados na ordem correta.

 Suponha que voc√™ esteja desenvolvendo um aplicativo de calculadora simples em uma interface gr√°fica. Quando o usu√°rio clica nos bot√µes num√©ricos e operadores, eventos de clique s√£o gerados. Esses eventos s√£o capturados por ouvintes associados a cada bot√£o, que atualizam a exibi√ß√£o da calculadora com os n√∫meros e operadores selecionados.
```JS
// Defini√ß√£o de fun√ß√£o para tratar o evento de clique em um bot√£o num√©rico
function handleNumericButtonClick(event) {
    const numericValue = event.target.textContent;
    updateDisplay(numericValue);
}

// Fun√ß√£o para atualizar a exibi√ß√£o da calculadora
function updateDisplay(value) {
    const displayElement = document.getElementById('calculator-display');
    displayElement.textContent += value;
}

// Adicionando ouvintes de eventos aos bot√µes num√©ricos
const numericButtons = document.querySelectorAll('.numeric-button');
numericButtons.forEach(button => {
    button.addEventListener('click', handleNumericButtonClick);
});
 ```
 Neste exemplo, cada vez que o usu√°rio clica em um bot√£o num√©rico na calculadora (representado por elementos HTML com a classe `.numeric-button`), o evento de clique √© capturado pelo ouvinte `handleNumericButtonClick`, que extrai o valor num√©rico do bot√£o clicado e atualiza a exibi√ß√£o da calculadora.<br/>
 Praticamente todas as linguagens de programa√ß√£o que t√™m suporte para interfaces gr√°ficas de usu√°rio (GUIs) ou aplicativos baseados em eventos suportam o paradigma de programa√ß√£o orientada a eventos. Alguns exemplos incluem:
 - JavaScript (para desenvolvimento web e aplicativos)
 - Python (com bibliotecas como Tkinter para desenvolvimento de GUIs)
 - Java (para desenvolvimento Android e aplicativos desktop)
 - C# (para desenvolvimento de aplicativos Windows com o framework .NET)
 - Swift (para desenvolvimento iOS e macOS)

 *C++ tamb√©m suporta o paradigma de programa√ß√£o orientada a eventos, especialmente quando utilizado em conjunto com bibliotecas ou frameworks que lidam com interfaces gr√°ficas de usu√°rio (GUIs) e intera√ß√µes do usu√°rio. Embora C++ n√£o tenha recursos nativos para lidar diretamente com eventos como em linguagens como JavaScript, ele pode ser utilizado para desenvolver aplicativos que respondam a eventos em sistemas desktop, jogos e outras aplica√ß√µes gr√°ficas. Por exemplo, ao desenvolver um aplicativo utilizando a biblioteca Qt, uma popular biblioteca C++ para o desenvolvimento de GUIs, voc√™ pode definir sinais e slots para lidar com eventos, onde os sinais representam eventos e os slots s√£o as fun√ß√µes que respondem a esses eventos. Assim, embora C++ n√£o seja t√£o frequentemente associado com programa√ß√£o orientada a eventos quanto JavaScript ou Java, ainda √© poss√≠vel utilizar esse paradigma em aplica√ß√µes C++ modernas, especialmente aquelas que envolvem interfaces gr√°ficas de usu√°rio.

#### PROGRAMA√á√ÉO ORIENTADA A OBJETOS
 Paradigma de programa√ß√£o baseado na utiliza√ß√£o de objetos e suas itera√ß√µes (an√°logo ao mundo real), a OO determina que o c√≥digo deve ser modelado de forma a se aproximar ao mundo real, e que o mesmo em execu√ß√£o no computador tenha tal modelagem representada por uma estrutura de objetos, caracter√≠sticas e a√ß√µes. Tais objetos podem interagir uns com os outros, modificando o estado do programa at√© que resultem nas sa√≠das esperadas. Vejamos o exemplo da caneta:
<pre>
 ---------------       ----------------------------        -------------
 | O QUE TENHO |       | O QUE SOU CAPAZ DE FAZER |        | COMO FA√áO |
 ---------------       ----------------------------        -------------
        ‚Üë                           ‚Üë                            ‚Üë
  CARACTER√çSTICA              COMPORTAMENTO                    ESTADO
     ATRIBUTO                   *M√âTODO*  ‚Ü∞                  *CONDI√á√ÉO* ‚¨é
     *CLASSE* ‚Üê UMA A ASSOCIADA FUN√á√ÉO ‚Ü≤   QUE DISPARA A EXECU√á√ÉO DE UM(A)
  ---------------            ---------------              ---------------
     - MODELO                  - ESCREVER                  - DESTAMPADA
     - COR                     - DESENHAR                  - TAMPADA
     - CARGA                   - RABISCAR                  - EM USO
     - CORPO                   - PINTAR
     - PONTA                   - DESTAMPAR
     - TAMPA
</pre>
 Para viabilizar essa estrutura, a OO prop√µe o uso de Classes, Atributos e M√©todos, unidos a caracter√≠sticas como Abstra√ß√£o, Encapsulamento, Heran√ßa e Polimorfismo. Os objetos s√£o inst√¢ncias das classes e possuem um estado durante a execu√ß√£o do software podendo as mesmas serem modificadas, persistidas e recarregadas de acordo com a l√≥gica implementada. Para classificarmos os diferentes modelos de caneta, identificamos cada caneta (objeto) agrupando suas caracter√≠sticas, comportamentos e estados. Os tipos de caneta podem variar, mas a base do modelo, ou seja, o padr√£o de comportamento e uso do objeto √© o mesmo, a base para identificar o que √© uma caneta √© generalizada.
<pre>
 ‚îå‚îÄ MODELO (CLASSE) ‚îÄ‚îê
 |     ATRIBUTOS     |
 |      M√âTODOS      |
 |      ESTADOS      |
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>
 Mas ent√£o, sobre o ponto de vista da programa√ß√£o, o que √© um objeto? O ato de criar um objeto de uma classe √© chamado de instancia√ß√£o. Isso ocorre usando o construtor da classe para alocar mem√≥ria e inicializar o objeto. Resumindo, uma inst√¢ncia √© um novo objeto criado a partir de uma classe. Um objeto √© descrito por caracter√≠sticas (atributos) espec√≠ficos, comportamentos (m√©todos) e estado (condi√ß√£o).

###### M√âTODOS COM ESTADO (INSTANCE) x M√âTODOS SEM ESTADO (STATIC)
 O estado descreve a condi√ß√£o do ambiente de execu√ß√£o em um momento espec√≠fico no tempo. Conforme o c√≥digo √© executado, os valores s√£o armazenados em vari√°veis. A qualquer momento durante sua execu√ß√£o, o estado atual do aplicativo √© a cole√ß√£o de todos os valores armazenados na mem√≥ria.<br/>
 Alguns m√©todos n√£o dependem do estado atual do aplicativo para funcionarem, em suma, os *m√©todos sem estado* s√£o implementados para que possam funcionar sem referenciar ou alterar os valores j√° armazenados na mem√≥ria. Os m√©todos sem estado tamb√©m s√£o conhecidos como *m√©todos est√°ticos (static)*.<br/>
 Por exemplo, em C#, o m√©todo `Console.WriteLine()` n√£o depende de nenhum valor armazenado na mem√≥ria. Ele executa sua fun√ß√£o e termina sem afetar o estado do aplicativo de qualquer forma. Outros m√©todos contudo, devem ter acesso ao estado do aplicativo para funcionarem. Em outras palavras, os *m√©todos com estado* s√£o s√£o criados de forma que dependem de valores armazenados na memr√≥ria pelas linhas de c√≥digo anteriormente executadas. Ou eles modificam o estado do aplicativo atualizando valores ou armazenando novos valores na mem√≥ria. Eles tamb√©m s√£o conhecidos como *m√©todos de inst√¢ncia*.<br/>
 Os m√©todos com estado *(inst√¢ncia)* controlam seu estado em *campos* (ou *propriedades*), que s√£o vari√°veis definidas na classe. Cada nova inst√¢ncia da classe tem sua pr√≥pria c√≥pia desses campos nos quais o estado √© armazenado. Uma √∫nica classe pode dar suporte a m√©todos com e sem estado. No entando, quando for necess√°rio chamar m√©todos com estado, deve-se primeiro criar uma inst√¢ncia da classe para que o m√©todo possa ser acessado. Resumidamente, *para utilizar um m√©todo sem estado n√£o √© obrigat√≥rio instanciar um objeto para us√°-lo, pois n√£o dependendem de dados armazenados na classe, geralmente s√£o m√©todos est√°ticos (ou fun√ß√µes livres) que operam apenas com os par√¢metros fornecidos.* Enquanto que, *para usar os m√©todos com estado, √© obrigat√≥rio instanciar um objeto, pois os m√©todos dependem do estado interno da classe (ou seja, dos atributos).* Um m√©todo sem estado permite ser chamado diretamente da classe enquanto um m√©todo com estado exige que seja criada uma inst√¢ncia.

```JS
// M√âTODO SEM ESTADO (STATIC)
class Math {
    static add(a, b){
        return a + b
    }
}
console.log(Math.add(5, 10)) // chamar "direto"
let calc = Math.add(10, 10)  // atribuir numa vari√°vel
console.log(calc)

// M√âTODO COM ESTADO (INSTANCE)
class Counter {
    constructor(count) {
        this.count = count;
    }

    increment(){
        this.count++;
    }

    getCount() {
        return this.count;
    }
}

const counter = new Counter(0)
for(let i = 0; i<3; i++) {
    counter.increment();
    console.log(counter.getCount())
}
```
###### CRIAR UMA INST√ÇNCIA DE CLASSE: INSTANCIANDO UM OBJETO
 Uma inst√¢ncia de uma classe √© chamada de um *objeto*. Para criar uma inst√¢ncia, em algumas linguagens √© necess√°rio a utiliza√ß√£o do operador `new`. Mas cada linguagem possui sua maneira, vejamos um exemplo no C++:

```C++
#include <iostream>
using namespace std;

// Defini√ß√£o da classe Caneta
class Caneta {
  public:
    // Atributos
    string cor;
    string carga;
    bool tampada;

    // M√©todo (Construtor)
    void escrever() {
      if(tampada == false){
        cout << "destampar caneta" << endl;
      }else{
        if(carga == "nova"){
          cout << "escrevendo com a caneta " << cor << endl;
        }else if(carga == "usada"){
          cout << "terminando de escrever com a caneta " << cor << endl;
        }else{
          cout << "usar outra caneta" << endl;
        }
      }
    }
};

int main() {
    // Criando um objeto da classe Caneta
    Caneta CanetaNova;
    Caneta CanetaUsada;

    // Atribuindo valores aos atributos

    // Caneta nova
    CanetaNova.cor = "preta";
    CanetaNova.carga = "nova";
    CanetaNova.tampada = true;

    // Caneta usada
    CanetaUsada.cor = "azul";
    CanetaUsada.carga = "usada";
    CanetaUsada.tampada = true;

    // Chamando o m√©todo
    CanetaNova.escrever();
    CanetaUsada.escrever();

    return 0;
}
```
 Ao criarmos um objeto, o c√≥digo realiza v√°rias a√ß√µes importantes. Ele (a instancia√ß√£o) solicita um endere√ßo na mem√≥ria do computador grande o suficiente para armazenar um novo objeto com base na classe de origem, e, retorna o endere√ßo de mem√≥ria para que possa ser salvo na vari√°vel atribu√≠da. Desse ponto em diante, quando a vari√°vel √© referenciada, o **Tempo de Execu√ß√£o** (ou equivalentes como **compilador**, **int√©rprete** e etc) executa uma pesquisa *"nos bastidores"* para que sinta-mos que estamos trabalhando diremente com o pr√≥prio objeto.

##### PILARES
 Os pilares da Programa√ß√£o Orientada a Objetos (POO) s√£o os conceitos fundamentais que orientam a forma como o c√≥digo √© organizado e estruturado em sistemas baseados em objetos. Vejamos melhor sobre os quatro principais pilares da POO s√£o:

 **1. ABSTRA√á√ÉO**: √© o processo de identificar os aspectos essenciais de um objeto e ignorar os detalhes irrelevantes. Em POO, isso √© alcan√ßado atrav√©s da cria√ß√£o de classes, que representam entidades ou conceitos do mundo real, e da defini√ß√£o de m√©todos que descrevem seu comportamento. Os detalhes de implementa√ß√£o s√£o encapsulados dentro das classes, permitindo que os usu√°rios das classes usem  apenas a interface p√∫blica, sem precisar entender como ela funciona internamente. Imagine que queremos representar um carro em um programa. Podemos criar uma classe `Carro` que encapsula as caracter√≠sticas e comportamentos de um carro.
```C++
 #include <iostream>
using namespace std;

// Classe representando um carro
class Carro {
  private:
    string CRLV;
    int chassi;

  public:
    // M√©todo construtor
    Carro(string doc, int c) {
      CRLV = doc;
      chassi = c;
    }

    // M√©todo para exibir os detalhes do carro
    void exibirDetalhes() {
      cout << "CRLV: " << CRLV << endl;
      cout << "N√∫mero do chassi: " << chassi << endl;
    }

    // M√©todo para ligar o carro
    void ligar() {
     cout << "O carro foi ligado." << endl;
    }

    // M√©todo para acelerar o carro
    void acelerar() {
     cout << "O carro est√° acelerando." << endl;
    }
};

int main() {

  // Criando um objeto da classe Carro
  Carro meuCarro("ABCDE12345", 543210);

  meuCarro.exibirDetalhes(); // Chamando o m√©todo para exibir os detalhes do carro
  meuCarro.ligar(); // Usando um m√©todo da classe Carro
  meuCarro.acelerar(); // Usando outro m√©todo da classe Carro

  return 0;
}
```

 **2. ENCAPSULAMENTO**: √© o princ√≠pio de ocultar os detalhes de implementa√ß√£o de uma classe e expondo apenas uma interface bem definida para interagir com o objeto. Isso √© feito usando modificadores de acesso para controlar o acesso aos membros da classe (m√©todos e vari√°veis). O encapsulamento ajuda a garantir a coes√£o dentro das classes, reduzindo o acoplamento entre elas e facilitando a manuten√ß√£o do c√≥digo.
```C++
#include <iostream>
using namespace std;

class ContaBancaria {

  private:
    float saldo; // Atributo privado

  public:
    // M√©todos p√∫blicos
    void depositar(float valor) {
      saldo += valor;
    }

    void sacar(float valor) {
      saldo -= valor;
    }

    float getSaldo() {
      return saldo;
    }

};

int main() {

  // Criando o objeto
  ContaBancaria conta;

  // Modificando os valores
  conta.depositar(1000);
  // Exibindo os valores
  cout << "Saldo atual: " << conta.getSaldo() << endl;

  // Modificando os valores
  conta.sacar(500);
  // Exibindo os valores
  cout << "Saldo atual: " << conta.getSaldo() << endl;

  return 0;
}
 ```
 Neste exemplo, o saldo da conta banc√°ria √© encapsulado dentro da classe `ContaBancaria`, e m√©todos p√∫blicos s√£o fornecidos para acessar e modificar esse saldo.

 **3. HERAN√áA**: √© um conceito pelo qual uma classe pode herdar atributos e m√©todos de outra classe (conhecida como superclasse ou classe base). A classe que herda √© chamada de subclasse ou classe derivada. A heran√ßa permite a reutiliza√ß√£o de c√≥digo, promove a extensibilidade do software e ajuda a organizar classes em uma hierarquia, onde as classes mais espec√≠ficas herdam comportamentos mais gerais das classes mais abstratas.
```C++
#include <iostream>
using namespace std;

class Animal {
  public:
    void comer() {
      cout << "O animal est√° comendo..." << endl;
    }
};

class Cachorro : public Animal {
  public:
    void latir() {
      cout << "O cachorro est√° latindo..." << endl;
    }
};

int main() {

  Cachorro meuCachorro;

  meuCachorro.comer();
  meuCachorro.latir(); // O m√©todo da classe Animal √© acessado atrav√©s da heran√ßa

  return 0;
}
```
 Neste exemplo, a classe `Cachorro` herda da classe `Animal`, ent√£o um objeto da classe `Cachorro` pode usar tanto o m√©todo `comer()` da classe `Animal` quanto seu pr√≥prio m√©todo `latir()`.

 **4. POLIMORFISMO**: significa *"muitas formas"* e refere-se √† capacidade de um objeto se comportar de maneiras diferentes dependendo do contexto em que √© usado. Uma classe filha (comportamentos e estados espec√≠ficos) herda as caracter√≠sticas (atributos e m√©todos) de uma classe m√£e (comportamentos e estados gerais).
```C++
#include <iostream>
using namespace std;

class Animal {
  public:
    virtual void fazerSom() {
      cout << "O animal est√° fazendo um som gen√©rico..." << endl;
    }
};

class Cachorro : public Animal {
  public:
    void fazerSom() override {
      cout << "O cachorro est√° latindo..." << endl;
    }
};

class Gato : public Animal {
  public:
    void fazerSom() override {
      cout << "O gato est√° miando..." << endl;
    }
};

int main() {

  Animal *animal;

  Cachorro meuCachorro;
  Gato meuGato;

  animal = &meuCachorro;
  animal->fazerSom(); // Polimorfismo - chama o m√©todo correto dependendo do tipo de objeto

  animal = &meuGato;
  animal->fazerSom(); // Polimorfismo novamente, chama o m√©todo correto dependendo do tipo de objeto

  return 0;

}
```
 Neste exemplo, o m√©todo `fazerSom()` √© virtual na classe base `Animal`, e √© sobrescrito nas classes derivadas `Cachorro` e `Gato`. Quando chamamos `fazerSom()` atrav√©s de um ponteiro para `Animal`, o m√©todo correto √© invocado com base no tipo de objeto ao qual o ponteiro aponta. Isso √© polimorfismo.

 Existem dois tipos principais de polimorfismo, polimorfismo de sobrecarga e polimorfismo de sobrescrita:
   
  **4.1. POLIMORFISMO DE SOBRECARGA**: ocorre quando duas ou mais fun√ß√µes t√™m o mesmo nome, mas argumentos diferentes (diferem em seus par√¢metros).
```C++
#include <iostream>
using namespace std;

class Operacoes {
  public:
    // Fun√ß√£o de soma para inteiros
    int soma(int a, int b) {
      return a + b;
    }

    // Fun√ß√£o de soma para floats
    float soma(float a, float b) {
      return a + b;
    }
};

int main() {

  Operacoes operacoes;

  // Chamando a fun√ß√£o soma para inteiros
  cout << "Soma de inteiros: " << operacoes.soma(5, 3) << endl;

  // Chamando a fun√ß√£o soma para floats
  cout << "Soma de floats: " << operacoes.soma(3.5f, 1.9f) << endl;

  return 0;

}
```
 Neste exemplo, temos duas fun√ß√µes chamadas `soma()`, uma para somar inteiros e outra para somar floats. Dependendo dos tipos de argumentos passados, o compilador escolher√° a fun√ß√£o correta para chamar.

  **4.2. POLIMORFISMO DE SOBRESCRISTA**: ocorre quando uma subclasse fornece uma implementa√ß√£o espec√≠fica para um m√©todo que j√° est√° sendo usado por sua superclasse.
```C++
#include <iostream>
using namespace std;
class Animal {
  public:
    // M√©todo fazerSom da classe base
    virtual void fazerSom() {
      cout << "Som gen√©rico de animal" << endl;
    }
};
class Cachorro : public Animal {
  public:
    // Sobrescrita do m√©todo fazerSom da classe base
    void fazerSom() override {
      cout << "Latido: Woof!" << endl;
    }
};
int main() {
  Animal* animal = new Cachorro(); // Criando um objeto Cachorro como Animal

  // Chamando o m√©todo fazerSom atrav√©s de um ponteiro Animal
  animal->fazerSom(); // Invocar√° o m√©todo fazerSom da classe Cachorro

  delete animal; // Liberando mem√≥ria alocada

  return 0;

}
```
 Neste exemplo, a classe `Cachorro` sobrescreve o m√©todo `fazerSom()` da classe `Animal`. Quando chamamos `fazerSom()` atrav√©s do ponteiro `Animal` que aponta para um objeto `Cachorro`, o m√©todo sobrescrito (`fazerSom()` de `Cachorro`) √© invocado. Isso √© polimorfismo de sobrescrita.

 Existem diferen√ßas entre as classes p√∫blicas e privadas na POO. Esta distin√ß√£o est√° relacionada √† visibilidade dos membros (m√©todos e vari√°veis) dentro de uma classe. 

 **5.1 Membros P√∫blicos (public):**
  - Os membros p√∫blicos s√£o acess√≠veis de fora da classe.
  - Eles podem ser acessados e utilizados por qualquer c√≥digo que tenha uma refer√™ncia para o objeto da classe.
  - Eles s√£o frequentemente usados para definir a interface p√∫blica da classe, ou seja, as opera√ß√µes que est√£o dispon√≠veis para os usu√°rios da classe.
  - Em muitas linguagens de programa√ß√£o, os membros p√∫blicos s√£o declarados usando o modificador public.

 Exemplo em Java:
```Java
public class MinhaClasse {
    public int variavelPublica;
    
    public void metodoPublico() {
        // Implementa√ß√£o do m√©todo
    }
}
```
 **5.2 Membros Privados (private):**
  - Os membros privados s√≥ s√£o acess√≠veis dentro da pr√≥pria classe.
  - Eles n√£o podem ser acessados ou modificados diretamente por c√≥digo fora da classe.
  - S√£o usados para esconder a implementa√ß√£o interna da classe e para garantir o encapsulamento.
  - A manipula√ß√£o dos membros privados geralmente √© feita por meio de m√©todos p√∫blicos, conhecidos como m√©todos acessores (getters) e modificadores (setters).
  - Em muitas linguagens de programa√ß√£o, os membros privados s√£o declarados usando o modificador private.

Exemplo em Java:
```Java
public class MinhaClasse {
    private int variavelPrivada;
    
    private void metodoPrivado() {
        // Implementa√ß√£o do m√©todo
    }

    // M√©todos acessores para variavelPrivada
    public int getVariavelPrivada() {
        return variavelPrivada;
    }

    public void setVariavelPrivada(int valor) {
        this.variavelPrivada = valor;
    }
}
```
 Vejamos alguns outros exemplos de como definir membros p√∫blicos e privados, desta vez em C++:
```C++
#include <iostream>

class MinhaClasse {
public:
    // Membro p√∫blico
    int variavelPublica;

    // M√©todo p√∫blico
    void metodoPublico() {
        std::cout << "M√©todo p√∫blico" << std::endl;
    }

private:
    // Membro privado
    int variavelPrivada;

    // M√©todo privado
    void metodoPrivado() {
        std::cout << "M√©todo privado" << std::endl;
    }

public:
    // M√©todos acessores para variavelPrivada
    int getVariavelPrivada() {
        return variavelPrivada;
    }

    void setVariavelPrivada(int valor) {
        variavelPrivada = valor;
    }
};

int main() {
    MinhaClasse obj;

    // Acesso a membros p√∫blicos
    obj.variavelPublica = 10;
    obj.metodoPublico();

    // Acesso a membros privados usando m√©todos acessores
    obj.setVariavelPrivada(20);
    std::cout << "Vari√°vel privada: " << obj.getVariavelPrivada() << std::endl;

    // N√£o √© poss√≠vel acessar membros privados diretamente
    // obj.variavelPrivada = 30;  // Isso geraria um erro de compila√ß√£o
    // obj.metodoPrivado();       // Isso geraria um erro de compila√ß√£o

    return 0;
}

```
 No exemplo acima, a classe MinhaClasse possui membros p√∫blicos (variavelPublica e metodoPublico) e membros privados (variavelPrivada e metodoPrivado). Os m√©todos acessores getVariavelPrivada e setVariavelPrivada permitem o acesso controlado √† vari√°vel privada variavelPrivada. O c√≥digo no main() demonstra como acessar membros p√∫blicos e privados dentro e fora da classe. Note que tentativas de acessar membros privados diretamente do c√≥digo principal resultariam em erros de compila√ß√£o, o que demonstra a encapsula√ß√£o de membros privados.<br/>
 A utiliza√ß√£o de membros p√∫blicos e privados permite controlar o acesso aos dados e funcionalidades de uma classe, promovendo o encapsulamento e a seguran√ßa do c√≥digo. Os membros p√∫blicos fornecem uma interface para intera√ß√£o com a classe, enquanto os membros privados ocultam os detalhes de implementa√ß√£o, reduzindo o acoplamento e facilitando a manuten√ß√£o do c√≥digo. Esses pilares s√£o fundamentais para a compreens√£o e implementa√ß√£o eficaz da POO e s√£o amplamente utilizados em muitas linguagens de programa√ß√£o, como Java, C++, Python, entre outras.

<a href="https://github.com/raphaelkaique1/study/blob/main/1-fundamentos_de_computacao/1.1-hardware_e_software/redes_de_computadores.md">previous</a>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä<a href="https://github.com/raphaelkaique1/study#conceitos_basicos">study</a>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä<a href="https://github.com/raphaelkaique1/study/blob/main/1-fundamentos_de_computacao/1.2-conceitos_basicos/estruturas_de_dados.md">next</a>